<!DOCTYPE html><html><head><meta charset="utf-8"/>
<meta name="viewport" content="target-densitydpi=low-dpi, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, width=device-width"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black"/><!-- default / black / black-translucent -->
<meta name="format-detection" content="telephone=no"/>
<title>cpuemu - Alpha1</title>
<meta property="og:image" content="cpuemu.png">
<link rel="apple-touch-icon" href="cpuemu.png"/>
<style>
body {
	font-family: sans-serif;
}
</style>
<script src="lib/fukuno.js"></script>
<script src="readmcode.js"></script>
<script src="ijfont.js"></script>
<script>"use strict";

var CPU = function() {
	this.r = []; // var:0-7, sp:13, link:14, pc:15
	this.status = {
		get: function() {
			var res = 0;
			res |= (this.n ? (1 << 31) : 0);
			res |= (this.z ? (1 << 30) : 0);
			res |= (this.c ? (1 << 29) : 0);
			res |= (this.v ? (1 << 28) : 0);
			res |= (this.q ? (1 << 27) : 0);
			res |= ((this.it & 3) << 25);
			res |= (this.j ? (1 << 24) : 0);
			res |= ((this.ge & 0xf) << 16);
			res |= ((this.it & 0xfc) << 8);
			res |= (this.E ? (1 << 9) : 0);
			res |= (this.A ? (1 << 8) : 0);
			res |= (this.I ? (1 << 7) : 0);
			res |= (this.F ? (1 << 6) : 0);
			res |= (this.t ? (1 << 5) : 0);
			res |= (this.mode & 0x1f);
			return res & 0xffffffff;
		},
		set: function(n) {
			this.n = (n & (1 << 31)) != 0;
			this.z = (n & (1 << 30)) != 0;
			this.c = (n & (1 << 29)) != 0;
			this.v = (n & (1 << 28)) != 0;
			this.q = (n & (1 << 27)) != 0;
			this.it = (((n >> 8) & 0xfc) | ((n >> 25) & 3));
			this.j = (n & (1 << 24)) != 0;
			this.ge = ((n >> 16) & 0xf);
			this.E = (n & (1 << 9)) != 0;
			this.A = (n & (1 << 8)) != 0;
			this.I = (n & (1 << 7)) != 0;
			this.F = (n & (1 << 6)) != 0;
			this.t = (n & (1 << 5)) != 0;
			this.mode = n & 0x1f;
		}
	};
	this.clockCount = 0;
	this.reset = function() {
		for (var i = 0; i < 16; i++)
			this.r[i] = 0;
		this.status.set(0);
		this.clockCount = 0;
	};
	this.reset();
	
	this.mem = {
		ram: [],
		check: function(ad, len) {
			for (var i = 0; i < len; i++) {
				if (isNaN(this.ram[ad + i])) return false;
			}
			return true;
		},
		get: function(ad) {
			if (isNaN(this.ram[ad])) return 0;
			return this.ram[ad];
		},
		set: function(ad, n) {
			this.ram[ad] = n & 0xff;
			if (this.notify) this.notify(ad);
		},
		get16: function(ad) {
			var n = this.get(ad);
			n |= this.get(ad + 1) << 8;
			return n;
		},
		set16: function(ad, n) {
			this.set(ad, n & 0xff);
			this.set(ad + 1, (n >> 8) & 0xff);
		},
		get32: function(ad) {
			var n = this.get16(ad);
			n |= this.get16(ad + 2) << 16;
			if (n < 0) n += 0x100000000;
			return n;
		},
		set32: function(ad, n) {
			this.set16(ad, n & 0xffff);
			this.set16(ad + 2, (n >> 16) & 0xffff);
		},
	};
	this.step = function() {
		var iaddr = this.r[15];
		if (iaddr === 0xDEADBEEE) { // 0xDEADBEEF & 0xfffffffe
			// instead of stopping execution at RET
			return 0;
		}
		if (iaddr % 2 != 0) {
			alert ("unaligned instructon read #" + iaddr.toString(16));
			return 0;
		}
		if (!this.mem.check(iaddr, 2) && get("uninitialized_memory").value === "halt") {
			alert("read instruction from uninitialized memory #" + iaddr.toString(16));
			return 0;
		}
		var code = this.mem.get16(iaddr);
//		this.code = code;
		this.r[15] += 2;
		if (this.r[15] >= 0x100000000) this.r[15] -= 0x100000000;
//		console.log(code.toString(2));
//		alert(code.toString(2));
		try {
			var chk = function(bin) {
				var n = parseInt(bin, 2);
				var c = code >> (16 - bin.length);
				return c == n;
			};
			var getu = function(start, n) {
				return (code >> start) & ((1 << n) - 1);
			};
			var getn = function(start, n) {
				var res = (code >> start) & ((1 << n) - 1);
				if ((res >> (n - 1)) != 0)
					return res - (1 << n);
				return res;
			};
			var norm = function(n) {
				var v = 0x100000000;
				while (n >= v) n -= v;
				while (n < 0) n += v;
				return n;
			};
			this.checkmem = function(addr, n, iswrite) {
				if (addr % n != 0) {
					throw "unaligned memory " + (iswrite ? "write" : "read") +
						" #" + addr.toString(16);
				}
				if (!iswrite && !this.mem.check(addr, n) &&
				get("uninitialized_memory").value === "halt") {
					throw "read from uninitialized memory #" + addr.toString(16);
				}
			};
			this.setflg = function(n) {
				this.status.z = n == 0;
				this.status.n = (n >> 31) != 0;
				return n;
			};
			this.addsetflg = function(n, m, carry = false) {
				n = norm(n);
				m = norm(m);
				var c = carry ? 1 : 0;
				var r = norm(n + m + c);
				var s = 0x80000000;
				this.status.c = n + m + c > 0xffffffff;
				this.status.v = (n & s) == (m & s) && (n & s) != (r & s);
				return this.setflg(r);
			};
			this.subsetflg = function(n, m, carry = false) {
				n = norm(n);
				m = norm(m);
				var c = carry ? 1 : 0;
				var r = norm(n - m - c);
				var s = 0x80000000;
				this.status.c = carry ? (n > m) : (n >= m);
				this.status.v = (n & s) != (m & s) && (n & s) != (r & s);
				return this.setflg(r);
			};
			if (chk("00100")) { // Rd = u8
				this.clockCount++;
				this.r[getu(8, 3)] = this.setflg(getu(0, 8));
			} else if (chk("01000110")) { // Rd = Rm
				this.clockCount++;
				var dstidx = getu(0, 3) | (getu(7, 1) << 3);
				var srcidx = getu(3, 4);
				var srcvalue;
				if (srcidx == 15) { // PC
					srcvalue = norm(this.r[srcidx] + 2); // PC + 4 = (PC + 2) + 2
				} else {
					srcvalue = this.r[srcidx];
				}
				if (dstidx == 15) { // PC
					this.clockCount += 2;
					this.r[dstidx] = norm(srcvalue & 0xfffffffe);
				} else {
					this.r[dstidx] = srcvalue;
				}
			} else if (chk("00110")) { // Rd += u8
				this.clockCount++;
				this.r[getu(8, 3)] = this.addsetflg(this.r[getu(8, 3)], getu(0, 8));
			} else if (chk("00111")) { // Rd -= u8
				this.clockCount++;
				this.r[getu(8, 3)] = this.subsetflg(this.r[getu(8, 3)], getu(0, 8));
			} else if (chk("10100")) { // Rd = PC + u8
				this.clockCount++;
				this.r[getu(8, 3)] = norm((this.r[15] + 2 + (getu(0, 8) << 2)) & 0xfffffffc);
			} else if (chk("01000100")) { // Rd += Rm
				this.clockCount++;
				var dstidx = getu(0, 3) | (getu(7, 1) << 3);
				var srcidx = getu(3, 4);
				if (srcidx == 15 && dstidx == 15) {
					throw "Rd += Rm with both PC isn't allowed";
				}
				var srcvalue;
				if (srcidx == 15) { // PC
					srcvalue = norm(this.r[srcidx] + 2); // PC + 4 = (PC + 2) + 2
				} else {
					srcvalue = this.r[srcidx];
				}
				if (dstidx == 15) { // PC
					this.clockCount += 2;
					this.r[dstidx] = norm((this.r[dstidx] + 2 + srcvalue) & 0xfffffffe);
				} else {
					this.r[dstidx] = norm(this.r[dstidx] + srcvalue);
				}
			} else if (chk("0001110")) { // Rd = Rn + u3
				this.clockCount++;
				this.r[getu(0, 3)] = this.addsetflg(this.r[getu(3, 3)], getu(6, 3));
			} else if (chk("0001111")) { // Rd = Rn - u3
				this.clockCount++;
				this.r[getu(0, 3)] = this.subsetflg(this.r[getu(3, 3)], getu(6, 3));
			} else if (chk("0001100")) { // Rd = Rn + Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.addsetflg(this.r[getu(3, 3)], this.r[getu(6, 3)]);
			} else if (chk("0001101")) { // Rd = Rn - Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.subsetflg(this.r[getu(3, 3)], this.r[getu(6, 3)]);
			} else if (chk("0100001001")) { // Rd = -Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.subsetflg(0, this.r[getu(3, 3)]);
			} else if (chk("0100001101")) { // Rd *= Rm
				this.clockCount++;
				// don't do this.r[getu(0, 3)] * this.r[getu(3, 3)], or the result will be inaccurate
				var ret = 0;
				var val = this.r[getu(0, 3)];
				var mult = this.r[getu(3, 3)];
				for (var i = 0; i < 32; i++) {
					if (mult & 1) ret = norm(ret + val);
					val = norm(val + val);
					mult >>>= 1;
				}
				this.r[getu(0, 3)] = this.setflg(ret);
			} else if (chk("00000")) { // Rd = Rm << u5
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				var s = getu(6, 5); // 0 <= s <= 31
				this.r[getu(0, 3)] = this.setflg(norm(v << s));
				if (s != 0) this.status.c = ((v >> (32 - s)) & 1) != 0;
			} else if (chk("00001")) { // Rd = Rm >> u5
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				var s = getu(6, 5); // 1 <= s <= 32
				if (s == 0) {
					this.r[getu(0, 3)] = this.setflg(0);
					this.status.c = ((v >> 31) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(norm(v >>> s));
					this.status.c = ((v >> (s - 1)) & 1) != 0;
				}
			} else if (chk("0100000010")) { // Rd <<= Rs
				this.clockCount++;
				var v = this.r[getu(0, 3)];
				var s = this.r[getu(3, 3)];
				if (0 <= s && s < 32) {
					this.r[getu(0, 3)] = this.setflg(norm(v << s));
					if (s != 0) this.status.c = ((v >> (32 - s)) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(0);
					this.status.c = s == 32 && (v & 1) != 0;
				}
			} else if (chk("0100000011")) { // Rd >>= Rs
				this.clockCount++;
				var v = this.r[getu(0, 3)];
				var s = this.r[getu(3, 3)];
				if (0 <= s && s < 32) {
					this.r[getu(0, 3)] = this.setflg(norm(v >>> s));
					if (s != 0) this.status.c = ((v >> (s - 1)) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(0);
					this.status.c = s == 32 && ((v >> 31) & 1) != 0;
				}
			} else if (chk("0100001111")) { // Rd = ~Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.setflg(norm(~this.r[getu(3, 3)]));
			} else if (chk("0100000000")) { // Rd &= Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.setflg(norm(this.r[getu(0, 3)] & this.r[getu(3, 3)]));
			} else if (chk("0100001100")) { // Rd |= Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.setflg(norm(this.r[getu(0, 3)] | this.r[getu(3, 3)]));
			} else if (chk("0100000001")) { // Rd ^= Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.setflg(norm(this.r[getu(0, 3)] ^ this.r[getu(3, 3)]));
			} else if (chk("01111")) { // Rd = [Rn + u5]
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5));
				this.checkmem(addr, 1, false);
				this.r[getu(0, 3)] = this.mem.get(addr);
			} else if (chk("10001")) { // Rd = [Rn + u5]W
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5) * 2);
				this.checkmem(addr, 2, false);
				this.r[getu(0, 3)] = this.mem.get16(addr);
			} else if (chk("01101")) { // Rd = [Rn + u5]L
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5) * 4);
				this.checkmem(addr, 4, false);
				this.r[getu(0, 3)] = this.mem.get32(addr);
			} else if (chk("01001")) { // Rd = [PC + u8]L
				this.clockCount += 2;
				var addr = norm((this.r[15] + 2 + getu(0, 8) * 4) & 0xfffffffc);
				this.checkmem(addr, 4, false);
				this.r[getu(8, 3)] = this.mem.get32(addr);
			} else if (chk("0101110")) { // Rd = [Rn + Rm]
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 1, false);
				this.r[getu(0, 3)] = this.mem.get(addr);
			} else if (chk("0101011")) { // Rd = [Rn + Rm]C
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 1, false);
				var value = this.mem.get(addr);
				if (value & 0x80) value = norm(value | 0xffffff00);
				this.r[getu(0, 3)] = value;
			} else if (chk("0101101")) { // Rd = [Rn + Rm]W
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 2, false);
				this.r[getu(0, 3)] = this.mem.get16(addr);
			} else if (chk("0101111")) { // Rd = [Rn + Rm]S
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 2, false);
				var value = this.mem.get16(addr);
				if (value & 0x8000) value = norm(value | 0xffff0000);
				this.r[getu(0, 3)] = value;
			} else if (chk("0101100")) { // Rd = [Rn + Rm]L
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 4, false);
				this.r[getu(0, 3)] = this.mem.get32(addr);
			} else if (chk("01110")) { // [Rn + u5] = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5));
				this.checkmem(addr, 1, true);
				this.mem.set(addr, this.r[getu(0, 3)]);
			} else if (chk("10000")) { // [Rn + u5]W = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5) * 2);
				this.checkmem(addr, 2, true);
				this.mem.set16(addr, this.r[getu(0, 3)]);
			} else if (chk("01100")) { // [Rn + u5]L = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5) * 4);
				this.checkmem(addr, 4, true);
				this.mem.set32(addr, this.r[getu(0, 3)]);
			} else if (chk("0101010")) { // [Rn + Rm] = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 1, true);
				this.mem.set(addr, this.r[getu(0, 3)]);
			} else if (chk("0101001")) { // [Rn + Rm]W = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 2, true);
				this.mem.set16(addr, this.r[getu(0, 3)]);
			} else if (chk("0101000")) { // [Rn + Rm]L = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 4, true);
				this.mem.set32(addr, this.r[getu(0, 3)]);
			} else if (chk("00101")) { // Rn - u8
				this.clockCount++;
				this.subsetflg(this.r[getu(8, 3)], getu(0, 8));
			} else if (chk("01000101")) { // Rn - Rm
				this.clockCount++;
				var nidx = (getu(7, 1) << 3) | getu(0, 3);
				var midx = getu(3, 4);
				if (nidx == 15 || midx == 15) {
					throw "using R15 in Rn - Rm is prohibited";
				}
				this.subsetflg(this.r[nidx], this.r[midx]);
			} else if (chk("0100001010")) { // Rn - Rm
				this.clockCount++;
				this.subsetflg(this.r[getu(0, 3)], this.r[getu(3, 3)]);
			} else if (chk("0100001011")) { // Rn + Rm
				this.clockCount++;
				this.addsetflg(this.r[getu(0, 3)], this.r[getu(3, 3)]);
			} else if (chk("0100001000")) { // Rn & Rm
				this.clockCount++;
				this.setflg(norm(this.r[getu(0, 3)] & this.r[getu(3, 3)]));
			} else if (chk("11011110")) { // Unused Opcode
				throw "Unused Opcode";
			} else if (chk("11011111")) { // SVC u8
				throw "SVC " + getu(0, 8) + " is executed";
			} else if (chk("1101")) { // IF cond GOTO n8
				this.clockCount++;
				var taken = false;
				switch (getu(9, 3)) {
					case 0: taken = this.status.z; break;
					case 1: taken = this.status.c; break;
					case 2: taken = this.status.n; break;
					case 3: taken = this.status.v; break;
					case 4: taken = !this.status.z && this.status.c; break;
					case 5: taken = this.status.n === this.status.v; break;
					case 6: taken = !this.status.z && this.status.n === this.status.v; break;
					case 7: taken = true; break; // this is BKPT / Unpredictable
				}
				if (getu(8, 1)) taken = !taken;
				if (taken) {
					this.clockCount += 2;
					// not +2 because PC+=2 is done already
					this.r[15] = norm(this.r[15] + ((getn(0, 8) + 1) << 1));
				}
			} else if (chk("11100")) { // GOTO n11
				this.clockCount += 3;
				// not +2 because PC+=2 is done already
				this.r[15] = norm(this.r[15] + ((getn(0, 11) + 1) << 1));
			} else if (chk("01000111")) { // GOTO Rm / GOSUB Rm
				this.clockCount += 3;
				var isgosub = getu(7, 1) === 1;
				var iname = isgosub ? "GOSUB" : "GOTO";
				if (getu(0, 3) !== 0) throw "instruction like " + iname + " Rm, but last 3 bits are not `000";
				var srcidx = getu(3, 4);
				if (srcidx === 13) throw "using SP for " + iname + " Rm is prohibited";
				if (srcidx === 15) throw "using PC for " + iname + " Rm is prohibited";
				if ((this.r[srcidx] & 1) === 0) {
//					if (!isgosub && srcidx == 14) { // RET
//						alert("ret");
//						return 0;
//					}
					throw "0 is passed as the LSB of the operand of " + iname + " Rm";
				}
				if (isgosub) this.r[14] = norm(this.r[15] | 1);
				this.r[15] = norm(this.r[srcidx] & 0xfffffffe);
			} else if (chk("11110")) { // GOSUB n22
				this.clockCount++;
				var upper = getn(0, 11);
				if (!this.mem.check(this.r[15], 2) && get("uninitialized_memory").value === "halt") {
					alert("read instruction from uninitialized memory #" + this.r[15].toString(16));
					return 0;
				}
				var inst2 = this.mem.get16(this.r[15]);
				if (((inst2 >> 11) & 0x1f) !== 0x1f) {
					throw "partial GOSUB n22 instruction";
				}
				this.clockCount += 3;
				var lower = inst2 & 0x7ff;
				var delta = (upper << 11) | lower;
				this.r[14] = norm((this.r[15] + 2) | 1);
				this.r[15] = norm(this.r[15] + 2 + delta * 2);
			} else if (chk("1011010")) { // PUSH {regs}
				this.clockCount++;
				var reglist = getu(0, 9);
				var sp = this.r[13];
				if (reglist & 0x100) {
					this.clockCount++;
					this.checkmem(sp = norm(sp - 4), 4, true);
					this.mem.set32(sp, this.r[14]);
				}
				for (var i = 7; i >= 0; i--) {
					if ((reglist >> i) & 1) {
						this.clockCount++;
						this.checkmem(sp = norm(sp - 4), 4, true);
						this.mem.set32(sp, this.r[i]);
					}
				}
				this.r[13] = sp;
			} else if (chk("1011110")) { // POP {regs}
				this.clockCount++;
				var reglist = getu(0, 9);
				var sp = this.r[13];
				for (var i = 0; i <= 7; i++) {
					if ((reglist >> i) & 1) {
						this.clockCount++;
						this.checkmem(sp, 4, false);
						this.r[i] = this.mem.get32(sp);
						sp = norm(sp + 4);
					}
				}
				if (reglist & 0x100) {
					this.clockCount += 4; // +1 for reglist and +3 for jump
					this.checkmem(sp, 4, false);
					var newpc = this.mem.get32(sp);
					sp = norm(sp + 4);
					this.r[13] = sp;
					if (newpc & 1) {
						this.r[15] = norm(newpc & 0xfffffffe);
					} else {
						throw "LSB of POPed value to PC is 0";
					}
				} else {
					this.r[13] = sp;
				}
			} else if (chk("101100000")) { // SP += u7
				this.clockCount++;
				this.r[13] = norm(this.r[13] + getu(0, 7) * 4);
			} else if (chk("101100001")) { // SP -= u7
				this.clockCount++;
				this.r[13] = norm(this.r[13] - getu(0, 7) * 4);
			} else if (chk("10101")) { // Rd = SP + u8
				this.clockCount++;
				this.r[getu(8, 3)] = norm(this.r[13] + getu(0, 8) * 4);
			} else if (chk("10011")) { // Rd = [SP + u8]L
				this.clockCount += 2;
				var addr = norm(this.r[13] + getu(0, 8) * 4);
				this.checkmem(addr, 4, false);
				this.r[getu(8, 3)] = this.mem.get32(addr);
			} else if (chk("10010")) { // [SP + u8]L = Rd
				this.clockCount += 2;
				var addr = norm(this.r[13] + getu(0, 8) * 4);
				this.checkmem(addr, 4, true);
				this.mem.set32(addr, this.r[getu(8, 3)]);
			} else if (chk("1011101000")) { // Rd = REV(Rm)
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				v = ((v >>> 8) & 0x00ff00ff) | ((v << 8) & 0xff00ff00);
				v = ((v >>> 16) & 0x0000ffff) | ((v << 16) & 0xffff0000);
				this.r[getu(0, 3)] = norm(v);
			} else if (chk("1011101001")) { // Rd = REV16(Rm)
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				v = ((v >>> 8) & 0x00ff00ff) | ((v << 8) & 0xff00ff00);
				this.r[getu(0, 3)] = norm(v);
			} else if (chk("1011101011")) { // Rd = REVSH(Rm)
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				v = ((v >>> 8) & 0x000000ff) | ((v << 8) & 0x0000ff00);
				if (v & 0x8000) v |= 0xffff0000;
				this.r[getu(0, 3)] = norm(v);
			} else if (chk("1011001001")) { // Rd = SXTB(Rm)
				this.clockCount++;
				var v = this.r[getu(3, 3)] & 0xff;
				if (v & 0x80) v |= 0xffffff00;
				this.r[getu(0, 3)] = norm(v);
			} else if (chk("1011001000")) { // Rd = SXTH(Rm)
				this.clockCount++;
				var v = this.r[getu(3, 3)] & 0xffff;
				if (v & 0x8000) v |= 0xffff0000;
				this.r[getu(0, 3)] = norm(v);
			} else if (chk("1011001011")) { // Rd = UXTB(Rm)
				this.clockCount++;
				this.r[getu(0, 3)] = norm(this.r[getu(3, 3)] & 0xff);
			} else if (chk("1011001010")) { // Rd = UXTH(Rm)
				this.clockCount++;
				this.r[getu(0, 3)] = norm(this.r[getu(3, 3)] & 0xffff);
			} else if (chk("00010")) { // Rd = ASR(Rm, u5)
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				var s = getu(6, 5); // 1 <= s <= 32
				if (s == 0) {
					this.r[getu(0, 3)] = this.setflg(norm(v >> 31));
					this.status.c = ((v >> 31) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(norm(v >> s));
					this.status.c = ((v >> (s - 1)) & 1) != 0;
				}
			} else if (chk("0100000100")) { // ASR Rd, Rs
				this.clockCount++;
				var v = this.r[getu(0, 3)];
				var s = this.r[getu(3, 3)];
				if (0 <= s && s < 32) {
					this.r[getu(0, 3)] = this.setflg(norm(v >> s));
					if (s != 0) this.status.c = ((v >> (s - 1)) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(norm(v >> 31));
					this.status.c = ((v >> 31) & 1) != 0;
				}
			} else if (chk("0100001110")) { // BIC Rd, Rm (Rd &= ~Rm)
				this.clockCount++;
				this.r[getu(0, 3)] = this.setflg(norm(this.r[getu(0, 3)] & ~this.r[getu(3, 3)]));
			} else if (chk("0100000111")) { // ROR Rd, Rs
				this.clockCount++;
				var v = this.r[getu(0, 3)];
				var s = this.r[getu(3, 3)];
				var s2 = s % 32;
				if (s2 == 0) {
					this.r[getu(0, 3)] = this.setflg(v);
					if (s != 0) this.status.c = ((v >> 31) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(norm((v >>> s2) | (v << (32 - s2))));
					this.status.c = ((v >> (s2 - 1)) & 1) != 0;
				}
			} else if (chk("0100000101")) { // ADC Rd, Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.addsetflg(this.r[getu(0, 3)], this.r[getu(3, 3)], this.status.c);
			} else if (chk("0100000110")) { // SBC Rd, Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.subsetflg(this.r[getu(0, 3)], this.r[getu(3, 3)], !this.status.c);
			} else if (chk("11001")) { // LDM Rn, {regs}
				this.clockCount++;
				var regs = getu(0, 8);
				if (regs == 0) {
					throw "LDM with empty regs";
				}
				var dstidx = getu(8, 3);
				var addr = this.r[dstidx];
				for (var i = 0; i < 8; i++) {
					if ((regs >> i) & 1) {
						this.clockCount++;
						this.checkmem(addr, 4, false);
						this.r[i] = this.mem.get32(addr);
						addr = norm(addr + 4);
					}
				}
				if (!((regs >> dstidx) & 1)) {
					this.r[dstidx] = addr;
				}
			} else if (chk("11000")) { // STM Rn, {regs}
				this.clockCount++;
				var regs = getu(0, 8);
				if (regs == 0) {
					throw "STM with empty regs";
				}
				var dstidx = getu(8, 3);
				if (((regs >> dstidx) & 1) && (regs & ((1 << dstidx) - 1))) {
					throw "STM with invalid combination of Rn and regs";
				}
				var addr = this.r[dstidx];
				for (var i = 0; i < 8; i++) {
					if ((regs >> i) & 1) {
						this.clockCount++;
						this.checkmem(addr, 4, true);
						this.mem.set32(addr, this.r[i]);
						addr = norm(addr + 4);
					}
				}
				this.r[dstidx] = addr;
			} else if (chk("10111110")) { // BKPT u8
				throw "BKPT " + getu(0, 8) + " is executed";
			// SVC u8 is not here but before IF cond GOTO n8 because they have common prefix
			} else {
				if (get("unsupported_op").value === "halt") {
					throw "unsupported instruction";
				}
			}
		} catch(e) {
			var inst = code.toString(2);
			while (inst.length < 16) inst = "0" + inst;
			alert("" + e + "\n\ninstruction address: #" + iaddr.toString(16) +
				"\ninstruction: " + inst);
			return 0;
		}
//		dump(this.r);
		return 1;
	};
};

window.onload = function() {
	var cpu = new CPU();
	
	for (var i = 0; i < 16; i++) {
		var r = create("div");
		r.textContent = "R" + i + ": ";
		r.ondblclick = (function(idx) {
			return function() {
				var rawRes = prompt("R" + idx + "の値を入力", cpu.r[idx]);
				if (rawRes !== null) {
					rawRes = rawRes.replace(/\s+/g, "");
					var res;
					if (rawRes.substr(0, 1) == '`') {
						res = parseInt(rawRes.substr(1), 2);
					} else if (rawRes.substr(0, 1) == '#') {
						res = parseInt(rawRes.substr(1), 16);
					} else {
						res = parseInt(rawRes);
					}
					if (!isNaN(res)) {
						res = res & 0xffffffff;
						if (res < 0) res += 0x100000000;
						cpu.r[idx] = res;
						showRegs();
					}
				}
			};
		})(i);
		get("regs").appendChild(r);
	}
	var flgnames = ["Negative", "Zero", "Carry", "Overflow"];
	for (var i = 0; i < 4; i++) {
		var r = create("div");
		r.textContent = flgnames[i] + "-flg: ";
		get("regs").appendChild(r);
	}
	{
		var r = create("div");
		r.style["margin-top"] = "1em";
		r.textContent = "Clock: ";
		get("regs").appendChild(r);
	}
	var showRegs = function() {
		var rs = get("regs").childNodes;
		for (var i = 0; i < 16; i++) {
			var negative = "";
			if (cpu.r[i] & 0x80000000) {
				negative = " (" + (cpu.r[i] - 0x100000000) + ")";
			}
			rs[i].textContent = "R" + i + ": " + cpu.r[i] + negative + " #" + cpu.r[i].toString(16);
		}
		rs[16].textContent = flgnames[0] + "-flg: " + cpu.status.n;
		rs[17].textContent = flgnames[1] + "-flg: " + cpu.status.z;
		rs[18].textContent = flgnames[2] + "-flg: " + cpu.status.c;
		rs[19].textContent = flgnames[3] + "-flg: " + cpu.status.v;
		rs[20].textContent = "Clock: " + cpu.clockCount;
	};
	
	var memDumpStartAddress = 0;
	var t, tr;
	t = create("table");
	tr = create("tr");
	tr.appendChild(create("th"));
	for (var i = 0; i < 16; i++) {
		var th = create("th");
		th.textContent = i.toString(16);
		if (i % 4 == 0) th.className = "mark";
		tr.appendChild(th);
	}
	t.appendChild(tr);
	var addressCellList = [];
	var byteCellList = [];
	var wordCellList = [];
	var longCellList = [];
	for (var i = 0; i < 0x1000; i += 16) {
		tr = create("tr");
		var td = create("td");
		td.textContent = "#" + i.toString(16);
		addressCellList.push(td);
		tr.appendChild(td);
		for (var j = 0; j < 16; j++) {
			td = create("td");
			td.textContent = "#00";
			if (j % 4 == 0) td.className = "mark";
			byteCellList.push(td);
			tr.appendChild(td);
			if (j % 2 == 0) {
				td = create("td");
				td.textContent = "#0000";
				td.colSpan = 2;
				td.style.display = "none";
				wordCellList.push(td);
				tr.appendChild(td);
			}
			if (j % 4 == 0) {
				td = create("td");
				td.textContent = "#00000000";
				td.colSpan = 4;
				td.style.display = "none";
				longCellList.push(td);
				tr.appendChild(td);
			}
		}
		t.appendChild(tr);
	}
	var displayingCellList = byteCellList;
	get("mem").appendChild(t);
	var memDumpFunc = function() {
		var kind = get("mem_format").value;
		if (kind == "signed") {
			return function(n, w) {
				if (w == 4) {
					return (n >= 0x80000000 ? n - 0x100000000 : n).toString(10);
				} else {
					var threshold = 1 << (w * 8 - 1);
					return (n >= threshold ? n - (1 << (w * 8)) : n).toString(10);
				}
			}
		} else if (kind == "unsigned") {
			return function(n, w) {
				return n.toString(10);
			}
		} else {
			return function(n, w) {
				var ret = n.toString(16);
				while (ret.length < w * 2) ret = "0" + ret;
				return "#" + ret;
			}
		}
	};
	cpu.mem.notify = function(addr) {
		var daddr = addr - memDumpStartAddress;
		if (0 <= daddr && daddr < 0x1000) {
			var f = memDumpFunc();
			byteCellList[daddr].textContent =
				cpu.mem.check(daddr + memDumpStartAddress, 1) ?
					f(cpu.mem.get(daddr + memDumpStartAddress), 1) : "??";
			var addrw = daddr >> 1;
			wordCellList[addrw].textContent =
				cpu.mem.check(addrw * 2 + memDumpStartAddress, 2) ?
					f(cpu.mem.get16(addrw * 2 + memDumpStartAddress), 2) : "????";
			var addrl = daddr >> 2;
			longCellList[addrl].textContent =
				cpu.mem.check(addrl * 4 + memDumpStartAddress, 4) ?
					f(cpu.mem.get32(addrl * 4 + memDumpStartAddress), 4) : "????????";
		}
	};
	var memDumpUpdateAll = function() {
		var f = memDumpFunc();
		for (var i = 0; i < 0x1000; i++) {
			var addr = memDumpStartAddress + i;
			byteCellList[i].textContent =
				cpu.mem.check(addr, 1) ? f(cpu.mem.get(addr), 1) : "??";
		}
		for (var i = 0; i < 0x1000; i += 2) {
			var addr = memDumpStartAddress + i;
			wordCellList[i >> 1].textContent =
				cpu.mem.check(addr, 2) ? f(cpu.mem.get16(addr), 2) : "????";
		}
		for (var i = 0; i < 0x1000; i += 4) {
			var addr = memDumpStartAddress + i;
			longCellList[i >> 2].textContent =
				cpu.mem.check(addr, 4) ? f(cpu.mem.get32(addr), 4) : "????????";
		}
		for (var i = 0; i < addressCellList.length; i++) {
			addressCellList[i].textContent = "#" + (memDumpStartAddress + i * 16).toString(16);
		}
	};
	var memDumpSwitchLength = function() {
		for (var i = 0; i < displayingCellList.length; i++) displayingCellList[i].style.display = "none";
		var arr;
		var len = get("mem_length").value;
		if (len === "byte") arr = byteCellList;
		else if (len === "word") arr = wordCellList;
		else if (len === "long") arr = longCellList;
		else arr = [];
		for (var i = 0; i < arr.length; i++) arr[i].style.display = "";
		displayingCellList = arr;
	};
	var memDumpSwitchSaddr = function() {
		var newval = parseInt(get("mem_saddr").value);
		if (!isNaN(newval) && 0 <= newval && newval <= 0x100000000 - 0x1000) {
			memDumpStartAddress = newval - (newval % 16);
			memDumpUpdateAll();
		}
	};
	get("mem_format").onchange = memDumpUpdateAll;
	get("mem_length").onchange = memDumpSwitchLength;
	get("mem_apply_saddr").onclick = memDumpSwitchSaddr;
	memDumpSwitchLength();
	memDumpSwitchSaddr();
	
	var prevRealMode = 0;
	var reset = function() {
		var realMode = parseInt(get("real_mode").value);
		cpu.reset();
		cpu.r[1] = 0x100;
		cpu.r[13] = 0x1000; // SP
		cpu.r[14] = 0xDEADBEEF; // LR
		cpu.r[15] = 0; // PC
		cpu.mem.ram = [];
		if (realMode > 0 && prevRealMode === 0 && memDumpStartAddress === 0) {
			memDumpStartAddress = 0x10000000;
		} else if (realMode === 0 && prevRealMode > 0 && memDumpStartAddress === 0x10000000) {
			memDumpStartAddress = 0;
		}
		prevRealMode = realMode;
		memDumpUpdateAll();
		if (realMode > 0) {
			var font = realMode >= 12 ? ijfont_1_2 : ijfont_1_1;
			var crom_addr = 0x1000;
			var cram_addr = 0x10000000;
			var div_addr = 0x2000;
			var div_data = [
				0x0A,0x46,0x01,0x46,0x00,0x20,0x01,0x23,
				0x91,0x42,0x0E,0xD3,0x12,0x42,0x0C,0xD0,
				0x04,0xD4,0x5B,0x00,0x52,0x00,0x01,0xD4,
				0x8A,0x42,0xFA,0xD3,0x91,0x42,0x01,0xD3,
				0x89,0x1A,0xC0,0x18,0x52,0x08,0x5B,0x08,
				0xF8,0xD1,0x70,0x47
			];
			for (var i = 0; i < 0xe0 * 8; i++) {
				cpu.mem.set(crom_addr + i, font[i]);
			}
			for (var i = 0; i < 0x20 * 8; i++) {
				cpu.mem.set(cram_addr + i, font[i + 0xe0 * 8]);
			}
			if (realMode >= 11) {
				cpu.r[1] = cram_addr - 0x700;
				cpu.r[2] = crom_addr;
			}
			if (realMode >= 12) {
				for (var i = 0; i < div_data.length; i++) {
					cpu.mem.set(div_addr + i, div_data[i]);
				}
				cpu.r[3] = div_addr | 1;
			}
			cpu.r[13] = 0x10001000;
			cpu.r[15] = 0x10000000;
		}
		autoflg = false;
		get("auto").textContent = "START";
		
		var n = 0;
		var memWrites = readMachineCode(get("prog").value);
		var binExists = false, pokeExists = false, arrayExists = false;
		for (var i = 0; i < memWrites.length; i++) {
			var kind = memWrites[i][2];
			if (kind === "bin") binExists = true;
			else if (kind === "poke") pokeExists = true;
			else if (kind === "array") arrayExists = true;
		}

		var offset = 0;
		if (realMode === 0) {
			if (binExists) offset = 0;
			else if (pokeExists) offset = 0x700;
			else if (arrayExists) offset = 0x800;
		} else {
			if (binExists) offset = 0;
			else if (pokeExists || arrayExists) offset = 0x700;
			offset -= 0x10000000;
		}
		for (var i = 0; i < memWrites.length; i++) {
			var addr = memWrites[i][0] - offset;
			cpu.mem.set(addr, memWrites[i][1]);
		}
		showRegs();
	};
	var autoflg = false;
	var auto = function() {
		if (autoflg) {
			autoflg = false;
			get("auto").textContent = "START";
			return;
		} else {
			autoflg = true;
			get("auto").textContent = "STOP";
		}
		var autostep = function() {
			if (!autoflg)
				return;
			if (cpu.step()) {
				setTimeout(autostep, get("autostep_interval").value);
			} else {
				autoflg = false;
				get("auto").textContent = "START";
			}
			showRegs();
		};
		autostep();
	};
	
	get("reset").onclick = reset;
	get("step").onclick = function() {
		autoflg = false;
		get("auto").textContent = "START";
		cpu.step();
		showRegs();
	};
	get("auto").onclick = auto;
	reset();
};

</script>
<style>
#credit {
	margin-top: 20px;
}
#prog {
	height: 400px;
	width: 14em;
	display: inline-block;
	font-size: 14px;
}
#regs {
	height: 400px;
	width: 23em;
	display: inline-block;
	font-size: 14px;
	vertical-align: top;
}
#mem {
	height: 400px;
	display: inline-block;
	font-size: 14px;
	vertical-align: top;
}
#mem table {
	display: block;
	overflow-y: scroll;
	height: 27em;
}
#mem td,th {
	border: 1px solid black;
	font-size: 14px;
	width: 2.5em;
}
#mem th:first-child {
	width: auto;
}
#mem td {
	text-align: right;
}
#mem .mark {
	background-color: #eee;
}

#config {
	margin-top: 1em;
	margin-bottom: 1em;
	font-size: 14px;
}
#main {
	padding: .5em;
}
a {
	color: #333 !important;
}
</style>
</head>
<body>

<h1>cpuemu - Alpha1</h1>
<div id=main>
使えるマシン語一覧: <a href=http://fukuno.jig.jp/1188>IchigoJamではじめるARMマシン語その3</a><br>
<br><textarea id=prog>0010001100001001
0000001000011011
0101010001011011
0011001100000001
0000101000011010
0010101000001010
1101000111111010
0100011101110000
</textarea>
<div id=regs></div>
<div id=mem>
format:<select id="mem_format">
<option value="hex" selected="selected">hex</option>
<option value="unsigned">unsigned dec</option>
<option value="signed">signed dec</option>
</select>
&nbsp;length:<select id="mem_length">
<option value="byte" selected="selected">byte</option>
<option value="word">word</option>
<option value="long">long</option>
</select>
&nbsp;start addr:<input id="mem_saddr" type="text" value="0x0" size="12">
<input id="mem_apply_saddr" type="button" value="GO">
<br>
</div>
<br>
<button id=auto>START</button>
<button id=step>STEP</button>
<button id=reset>RESET</button>
</div>
<div id="config">
未サポートの命令<select id="unsupported_op">
<option value="ignore">を無視</option>
<option value="halt" selected="selected">で停止</option>
</select><br>
未初期化のメモリを読んだら<select id="uninitialized_memory">
<option value="zero">0とみなす</option>
<option value="halt" selected="selected">停止する</option>
</select><br>
自動実行の速さは<select id="autostep_interval">
<option value="10">高速</option>
<option value="100" selected="selected">通常</option>
</select><br>
IchigoJam再現モード<select id="real_mode">
<option value="0" selected="selected">オフ</option>
<option value="10">1.0風</option>
<option value="11">1.1風</option>
<option value="12">1.2風</option>
</select> ※非公認
</div>
<div id='credit'>
cpuemu a1 (for <a href=http://ichigojam.net/>IchigoJam</a>)<br>
<a href="https://ichigojam.github.io/asm15/cpuemu.html">Original</a> APP: <a href='http://fukuno.jig.jp/1328'>CC BY fukuno.jig.jp</a><br>
Modified By みけCAT<br>
Modification: <a href="https://creativecommons.org/licenses/by/4.0/deed.ja">CC BY 4.0</a> by みけCAT<br>
IchigoJam FONT(Original): CC BY IchigoJam(<a href="http://ichigojam.net/">http://ichigojam.net/</a>)
</div>

</body>
<html>
