<!DOCTYPE html><html><head><meta charset="utf-8">
<meta name="viewport" content="target-densitydpi=low-dpi, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, width=device-width"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black"/><!-- default / black / black-translucent -->
<meta name="format-detection" content="telephone=no"/>
<title>cpuemu - Alpha1</title>
<meta property="og:image" content="cpuemu.png">
<link rel="apple-touch-icon" href="cpuemu.png"/>
<style>
body {
	font-family: sans-serif;
}
</style>
<script src="lib/fukuno.js"></script>
<script src="readmcode.js"></script>
<script src="ijfont.js"></script>
<script>"use strict";

var MEM = function() {
	return {
		ram: [],
		check: function(ad, len) {
			for (var i = 0; i < len; i++) {
				if (isNaN(this.ram[ad + i])) return false;
			}
			return true;
		},
		get: function(ad) {
			if (isNaN(this.ram[ad])) return 0;
			return this.ram[ad];
		},
		set: function(ad, n) {
			this.ram[ad] = n & 0xff;
			if (this.notify) this.notify(ad);
		},
		get16: function(ad) {
			var n = this.get(ad);
			n |= this.get(ad + 1) << 8;
			return n;
		},
		set16: function(ad, n) {
			this.set(ad, n & 0xff);
			this.set(ad + 1, (n >> 8) & 0xff);
		},
		get32: function(ad) {
			var n = this.get16(ad);
			n |= this.get16(ad + 2) << 16;
			if (n < 0) n += 0x100000000;
			return n;
		},
		set32: function(ad, n) {
			this.set16(ad, n & 0xffff);
			this.set16(ad + 2, (n >> 16) & 0xffff);
		},
	};
}

var CPU_M0 = function() {
	this.r = []; // var:0-7, sp:13, link:14, pc:15
	this.status = {
		get: function() {
			var res = 0;
			res |= (this.n ? (1 << 31) : 0);
			res |= (this.z ? (1 << 30) : 0);
			res |= (this.c ? (1 << 29) : 0);
			res |= (this.v ? (1 << 28) : 0);
			res |= (this.q ? (1 << 27) : 0);
			res |= ((this.it & 3) << 25);
			res |= (this.j ? (1 << 24) : 0);
			res |= ((this.ge & 0xf) << 16);
			res |= ((this.it & 0xfc) << 8);
			res |= (this.E ? (1 << 9) : 0);
			res |= (this.A ? (1 << 8) : 0);
			res |= (this.I ? (1 << 7) : 0);
			res |= (this.F ? (1 << 6) : 0);
			res |= (this.t ? (1 << 5) : 0);
			res |= (this.mode & 0x1f);
			return res & 0xffffffff;
		},
		set: function(n) {
			this.n = (n & (1 << 31)) != 0;
			this.z = (n & (1 << 30)) != 0;
			this.c = (n & (1 << 29)) != 0;
			this.v = (n & (1 << 28)) != 0;
			this.q = (n & (1 << 27)) != 0;
			this.it = (((n >> 8) & 0xfc) | ((n >> 25) & 3));
			this.j = (n & (1 << 24)) != 0;
			this.ge = ((n >> 16) & 0xf);
			this.E = (n & (1 << 9)) != 0;
			this.A = (n & (1 << 8)) != 0;
			this.I = (n & (1 << 7)) != 0;
			this.F = (n & (1 << 6)) != 0;
			this.t = (n & (1 << 5)) != 0;
			this.mode = n & 0x1f;
		}
	};
	this.clockCount = 0;
	this.reset = function() {
		for (var i = 0; i < 16; i++)
			this.r[i] = 0;
		this.status.set(0);
		this.clockCount = 0;
	};
	this.reset();
	
	this.mem = new MEM();
	this.step = function() {
		var iaddr = this.r[15];
		if (iaddr === 0xDEADBEEE) { // 0xDEADBEEF & 0xfffffffe
			// instead of stopping execution at RET
			return 0;
		}
		if (iaddr % 2 != 0) {
			alert ("unaligned instructon read #" + iaddr.toString(16));
			return 0;
		}
		if (!this.mem.check(iaddr, 2) && get("uninitialized_memory").value === "halt") {
			alert("read instruction from uninitialized memory #" + iaddr.toString(16));
			return 0;
		}
		var code = this.mem.get16(iaddr);
//		this.code = code;
		this.r[15] += 2;
		if (this.r[15] >= 0x100000000) this.r[15] -= 0x100000000;
//		console.log(code.toString(2));
//		alert(code.toString(2));
		try {
			var chk = function(bin) {
				var n = parseInt(bin, 2);
				var c = code >> (16 - bin.length);
				return c == n;
			};
			var getu = function(start, n) {
				return (code >> start) & ((1 << n) - 1);
			};
			var getn = function(start, n) {
				var res = (code >> start) & ((1 << n) - 1);
				if ((res >> (n - 1)) != 0)
					return res - (1 << n);
				return res;
			};
			var norm = function(n) {
				var v = 0x100000000;
				while (n >= v) n -= v;
				while (n < 0) n += v;
				return n;
			};
			this.checkmem = function(addr, n, iswrite) {
				if (addr % n != 0) {
					throw "unaligned memory " + (iswrite ? "write" : "read") +
						" #" + addr.toString(16);
				}
				if (!iswrite && !this.mem.check(addr, n) &&
				get("uninitialized_memory").value === "halt") {
					throw "read from uninitialized memory #" + addr.toString(16);
				}
			};
			this.setflg = function(n) {
				this.status.z = n == 0;
				this.status.n = (n >> 31) != 0;
				return n;
			};
			this.addsetflg = function(n, m, carry = false) {
				n = norm(n);
				m = norm(m);
				var c = carry ? 1 : 0;
				var r = norm(n + m + c);
				var s = 0x80000000;
				this.status.c = n + m + c > 0xffffffff;
				this.status.v = (n & s) == (m & s) && (n & s) != (r & s);
				return this.setflg(r);
			};
			this.subsetflg = function(n, m, carry = false) {
				n = norm(n);
				m = norm(m);
				var c = carry ? 1 : 0;
				var r = norm(n - m - c);
				var s = 0x80000000;
				this.status.c = carry ? (n > m) : (n >= m);
				this.status.v = (n & s) != (m & s) && (n & s) != (r & s);
				return this.setflg(r);
			};
			if (chk("00100")) { // Rd = u8
				this.clockCount++;
				this.r[getu(8, 3)] = this.setflg(getu(0, 8));
			} else if (chk("01000110")) { // Rd = Rm
				this.clockCount++;
				var dstidx = getu(0, 3) | (getu(7, 1) << 3);
				var srcidx = getu(3, 4);
				var srcvalue;
				if (srcidx == 15) { // PC
					srcvalue = norm(this.r[srcidx] + 2); // PC + 4 = (PC + 2) + 2
				} else {
					srcvalue = this.r[srcidx];
				}
				if (dstidx == 15) { // PC
					this.clockCount += 2;
					this.r[dstidx] = norm(srcvalue & 0xfffffffe);
				} else {
					this.r[dstidx] = srcvalue;
				}
			} else if (chk("00110")) { // Rd += u8
				this.clockCount++;
				this.r[getu(8, 3)] = this.addsetflg(this.r[getu(8, 3)], getu(0, 8));
			} else if (chk("00111")) { // Rd -= u8
				this.clockCount++;
				this.r[getu(8, 3)] = this.subsetflg(this.r[getu(8, 3)], getu(0, 8));
			} else if (chk("10100")) { // Rd = PC + u8
				this.clockCount++;
				this.r[getu(8, 3)] = norm((this.r[15] + 2 + (getu(0, 8) << 2)) & 0xfffffffc);
			} else if (chk("01000100")) { // Rd += Rm
				this.clockCount++;
				var dstidx = getu(0, 3) | (getu(7, 1) << 3);
				var srcidx = getu(3, 4);
				if (srcidx == 15 && dstidx == 15) {
					throw "Rd += Rm with both PC isn't allowed";
				}
				var srcvalue;
				if (srcidx == 15) { // PC
					srcvalue = norm(this.r[srcidx] + 2); // PC + 4 = (PC + 2) + 2
				} else {
					srcvalue = this.r[srcidx];
				}
				if (dstidx == 15) { // PC
					this.clockCount += 2;
					this.r[dstidx] = norm((this.r[dstidx] + 2 + srcvalue) & 0xfffffffe);
				} else {
					this.r[dstidx] = norm(this.r[dstidx] + srcvalue);
				}
			} else if (chk("0001110")) { // Rd = Rn + u3
				this.clockCount++;
				this.r[getu(0, 3)] = this.addsetflg(this.r[getu(3, 3)], getu(6, 3));
			} else if (chk("0001111")) { // Rd = Rn - u3
				this.clockCount++;
				this.r[getu(0, 3)] = this.subsetflg(this.r[getu(3, 3)], getu(6, 3));
			} else if (chk("0001100")) { // Rd = Rn + Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.addsetflg(this.r[getu(3, 3)], this.r[getu(6, 3)]);
			} else if (chk("0001101")) { // Rd = Rn - Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.subsetflg(this.r[getu(3, 3)], this.r[getu(6, 3)]);
			} else if (chk("0100001001")) { // Rd = -Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.subsetflg(0, this.r[getu(3, 3)]);
			} else if (chk("0100001101")) { // Rd *= Rm
				this.clockCount++;
				// don't do this.r[getu(0, 3)] * this.r[getu(3, 3)], or the result will be inaccurate
				var ret = 0;
				var val = this.r[getu(0, 3)];
				var mult = this.r[getu(3, 3)];
				for (var i = 0; i < 32; i++) {
					if (mult & 1) ret = norm(ret + val);
					val = norm(val + val);
					mult >>>= 1;
				}
				this.r[getu(0, 3)] = this.setflg(ret);
			} else if (chk("00000")) { // Rd = Rm << u5
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				var s = getu(6, 5); // 0 <= s <= 31
				this.r[getu(0, 3)] = this.setflg(norm(v << s));
				if (s != 0) this.status.c = ((v >> (32 - s)) & 1) != 0;
			} else if (chk("00001")) { // Rd = Rm >> u5
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				var s = getu(6, 5); // 1 <= s <= 32
				if (s == 0) {
					this.r[getu(0, 3)] = this.setflg(0);
					this.status.c = ((v >> 31) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(norm(v >>> s));
					this.status.c = ((v >> (s - 1)) & 1) != 0;
				}
			} else if (chk("0100000010")) { // Rd <<= Rs
				this.clockCount++;
				var v = this.r[getu(0, 3)];
				var s = this.r[getu(3, 3)];
				if (0 <= s && s < 32) {
					this.r[getu(0, 3)] = this.setflg(norm(v << s));
					if (s != 0) this.status.c = ((v >> (32 - s)) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(0);
					this.status.c = s == 32 && (v & 1) != 0;
				}
			} else if (chk("0100000011")) { // Rd >>= Rs
				this.clockCount++;
				var v = this.r[getu(0, 3)];
				var s = this.r[getu(3, 3)];
				if (0 <= s && s < 32) {
					this.r[getu(0, 3)] = this.setflg(norm(v >>> s));
					if (s != 0) this.status.c = ((v >> (s - 1)) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(0);
					this.status.c = s == 32 && ((v >> 31) & 1) != 0;
				}
			} else if (chk("0100001111")) { // Rd = ~Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.setflg(norm(~this.r[getu(3, 3)]));
			} else if (chk("0100000000")) { // Rd &= Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.setflg(norm(this.r[getu(0, 3)] & this.r[getu(3, 3)]));
			} else if (chk("0100001100")) { // Rd |= Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.setflg(norm(this.r[getu(0, 3)] | this.r[getu(3, 3)]));
			} else if (chk("0100000001")) { // Rd ^= Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.setflg(norm(this.r[getu(0, 3)] ^ this.r[getu(3, 3)]));
			} else if (chk("01111")) { // Rd = [Rn + u5]
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5));
				this.checkmem(addr, 1, false);
				this.r[getu(0, 3)] = this.mem.get(addr);
			} else if (chk("10001")) { // Rd = [Rn + u5]W
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5) * 2);
				this.checkmem(addr, 2, false);
				this.r[getu(0, 3)] = this.mem.get16(addr);
			} else if (chk("01101")) { // Rd = [Rn + u5]L
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5) * 4);
				this.checkmem(addr, 4, false);
				this.r[getu(0, 3)] = this.mem.get32(addr);
			} else if (chk("01001")) { // Rd = [PC + u8]L
				this.clockCount += 2;
				var addr = norm((this.r[15] + 2 + getu(0, 8) * 4) & 0xfffffffc);
				this.checkmem(addr, 4, false);
				this.r[getu(8, 3)] = this.mem.get32(addr);
			} else if (chk("0101110")) { // Rd = [Rn + Rm]
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 1, false);
				this.r[getu(0, 3)] = this.mem.get(addr);
			} else if (chk("0101011")) { // Rd = [Rn + Rm]C
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 1, false);
				var value = this.mem.get(addr);
				if (value & 0x80) value = norm(value | 0xffffff00);
				this.r[getu(0, 3)] = value;
			} else if (chk("0101101")) { // Rd = [Rn + Rm]W
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 2, false);
				this.r[getu(0, 3)] = this.mem.get16(addr);
			} else if (chk("0101111")) { // Rd = [Rn + Rm]S
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 2, false);
				var value = this.mem.get16(addr);
				if (value & 0x8000) value = norm(value | 0xffff0000);
				this.r[getu(0, 3)] = value;
			} else if (chk("0101100")) { // Rd = [Rn + Rm]L
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 4, false);
				this.r[getu(0, 3)] = this.mem.get32(addr);
			} else if (chk("01110")) { // [Rn + u5] = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5));
				this.checkmem(addr, 1, true);
				this.mem.set(addr, this.r[getu(0, 3)]);
			} else if (chk("10000")) { // [Rn + u5]W = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5) * 2);
				this.checkmem(addr, 2, true);
				this.mem.set16(addr, this.r[getu(0, 3)]);
			} else if (chk("01100")) { // [Rn + u5]L = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + getu(6, 5) * 4);
				this.checkmem(addr, 4, true);
				this.mem.set32(addr, this.r[getu(0, 3)]);
			} else if (chk("0101010")) { // [Rn + Rm] = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 1, true);
				this.mem.set(addr, this.r[getu(0, 3)]);
			} else if (chk("0101001")) { // [Rn + Rm]W = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 2, true);
				this.mem.set16(addr, this.r[getu(0, 3)]);
			} else if (chk("0101000")) { // [Rn + Rm]L = Rd
				this.clockCount += 2;
				var addr = norm(this.r[getu(3, 3)] + this.r[getu(6, 3)]);
				this.checkmem(addr, 4, true);
				this.mem.set32(addr, this.r[getu(0, 3)]);
			} else if (chk("00101")) { // Rn - u8
				this.clockCount++;
				this.subsetflg(this.r[getu(8, 3)], getu(0, 8));
			} else if (chk("01000101")) { // Rn - Rm
				this.clockCount++;
				var nidx = (getu(7, 1) << 3) | getu(0, 3);
				var midx = getu(3, 4);
				if (nidx == 15 || midx == 15) {
					throw "using R15 in Rn - Rm is prohibited";
				}
				this.subsetflg(this.r[nidx], this.r[midx]);
			} else if (chk("0100001010")) { // Rn - Rm
				this.clockCount++;
				this.subsetflg(this.r[getu(0, 3)], this.r[getu(3, 3)]);
			} else if (chk("0100001011")) { // Rn + Rm
				this.clockCount++;
				this.addsetflg(this.r[getu(0, 3)], this.r[getu(3, 3)]);
			} else if (chk("0100001000")) { // Rn & Rm
				this.clockCount++;
				this.setflg(norm(this.r[getu(0, 3)] & this.r[getu(3, 3)]));
			} else if (chk("11011110")) { // Unused Opcode
				throw "Unused Opcode";
			} else if (chk("11011111")) { // SVC u8
				throw "SVC " + getu(0, 8) + " is executed";
			} else if (chk("1101")) { // IF cond GOTO n8
				this.clockCount++;
				var taken = false;
				switch (getu(9, 3)) {
					case 0: taken = this.status.z; break;
					case 1: taken = this.status.c; break;
					case 2: taken = this.status.n; break;
					case 3: taken = this.status.v; break;
					case 4: taken = !this.status.z && this.status.c; break;
					case 5: taken = this.status.n === this.status.v; break;
					case 6: taken = !this.status.z && this.status.n === this.status.v; break;
					case 7: taken = true; break; // this is BKPT / Unpredictable
				}
				if (getu(8, 1)) taken = !taken;
				if (taken) {
					this.clockCount += 2;
					// not +2 because PC+=2 is done already
					this.r[15] = norm(this.r[15] + ((getn(0, 8) + 1) << 1));
				}
			} else if (chk("11100")) { // GOTO n11
				this.clockCount += 3;
				// not +2 because PC+=2 is done already
				this.r[15] = norm(this.r[15] + ((getn(0, 11) + 1) << 1));
			} else if (chk("01000111")) { // GOTO Rm / GOSUB Rm
				this.clockCount += 3;
				var isgosub = getu(7, 1) === 1;
				var iname = isgosub ? "GOSUB" : "GOTO";
				if (getu(0, 3) !== 0) throw "instruction like " + iname + " Rm, but last 3 bits are not `000";
				var srcidx = getu(3, 4);
				if (srcidx === 13) throw "using SP for " + iname + " Rm is prohibited";
				if (srcidx === 15) throw "using PC for " + iname + " Rm is prohibited";
				if ((this.r[srcidx] & 1) === 0) {
//					if (!isgosub && srcidx == 14) { // RET
//						alert("ret");
//						return 0;
//					}
					throw "0 is passed as the LSB of the operand of " + iname + " Rm";
				}
				if (isgosub) this.r[14] = norm(this.r[15] | 1);
				this.r[15] = norm(this.r[srcidx] & 0xfffffffe);
			} else if (chk("11110")) { // GOSUB n22
				this.clockCount++;
				var upper = getn(0, 11);
				if (!this.mem.check(this.r[15], 2) && get("uninitialized_memory").value === "halt") {
					alert("read instruction from uninitialized memory #" + this.r[15].toString(16));
					return 0;
				}
				var inst2 = this.mem.get16(this.r[15]);
				if (((inst2 >> 11) & 0x1f) !== 0x1f) {
					throw "partial GOSUB n22 instruction";
				}
				this.clockCount += 3;
				var lower = inst2 & 0x7ff;
				var delta = (upper << 11) | lower;
				this.r[14] = norm((this.r[15] + 2) | 1);
				this.r[15] = norm(this.r[15] + 2 + delta * 2);
			} else if (chk("1011010")) { // PUSH {regs}
				this.clockCount++;
				var reglist = getu(0, 9);
				var sp = this.r[13];
				if (reglist & 0x100) {
					this.clockCount++;
					this.checkmem(sp = norm(sp - 4), 4, true);
					this.mem.set32(sp, this.r[14]);
				}
				for (var i = 7; i >= 0; i--) {
					if ((reglist >> i) & 1) {
						this.clockCount++;
						this.checkmem(sp = norm(sp - 4), 4, true);
						this.mem.set32(sp, this.r[i]);
					}
				}
				this.r[13] = sp;
			} else if (chk("1011110")) { // POP {regs}
				this.clockCount++;
				var reglist = getu(0, 9);
				var sp = this.r[13];
				for (var i = 0; i <= 7; i++) {
					if ((reglist >> i) & 1) {
						this.clockCount++;
						this.checkmem(sp, 4, false);
						this.r[i] = this.mem.get32(sp);
						sp = norm(sp + 4);
					}
				}
				if (reglist & 0x100) {
					this.clockCount += 4; // +1 for reglist and +3 for jump
					this.checkmem(sp, 4, false);
					var newpc = this.mem.get32(sp);
					sp = norm(sp + 4);
					this.r[13] = sp;
					if (newpc & 1) {
						this.r[15] = norm(newpc & 0xfffffffe);
					} else {
						throw "LSB of POPed value to PC is 0";
					}
				} else {
					this.r[13] = sp;
				}
			} else if (chk("101100000")) { // SP += u7
				this.clockCount++;
				this.r[13] = norm(this.r[13] + getu(0, 7) * 4);
			} else if (chk("101100001")) { // SP -= u7
				this.clockCount++;
				this.r[13] = norm(this.r[13] - getu(0, 7) * 4);
			} else if (chk("10101")) { // Rd = SP + u8
				this.clockCount++;
				this.r[getu(8, 3)] = norm(this.r[13] + getu(0, 8) * 4);
			} else if (chk("10011")) { // Rd = [SP + u8]L
				this.clockCount += 2;
				var addr = norm(this.r[13] + getu(0, 8) * 4);
				this.checkmem(addr, 4, false);
				this.r[getu(8, 3)] = this.mem.get32(addr);
			} else if (chk("10010")) { // [SP + u8]L = Rd
				this.clockCount += 2;
				var addr = norm(this.r[13] + getu(0, 8) * 4);
				this.checkmem(addr, 4, true);
				this.mem.set32(addr, this.r[getu(8, 3)]);
			} else if (chk("1011101000")) { // Rd = REV(Rm)
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				v = ((v >>> 8) & 0x00ff00ff) | ((v << 8) & 0xff00ff00);
				v = ((v >>> 16) & 0x0000ffff) | ((v << 16) & 0xffff0000);
				this.r[getu(0, 3)] = norm(v);
			} else if (chk("1011101001")) { // Rd = REV16(Rm)
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				v = ((v >>> 8) & 0x00ff00ff) | ((v << 8) & 0xff00ff00);
				this.r[getu(0, 3)] = norm(v);
			} else if (chk("1011101011")) { // Rd = REVSH(Rm)
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				v = ((v >>> 8) & 0x000000ff) | ((v << 8) & 0x0000ff00);
				if (v & 0x8000) v |= 0xffff0000;
				this.r[getu(0, 3)] = norm(v);
			} else if (chk("1011001001")) { // Rd = SXTB(Rm)
				this.clockCount++;
				var v = this.r[getu(3, 3)] & 0xff;
				if (v & 0x80) v |= 0xffffff00;
				this.r[getu(0, 3)] = norm(v);
			} else if (chk("1011001000")) { // Rd = SXTH(Rm)
				this.clockCount++;
				var v = this.r[getu(3, 3)] & 0xffff;
				if (v & 0x8000) v |= 0xffff0000;
				this.r[getu(0, 3)] = norm(v);
			} else if (chk("1011001011")) { // Rd = UXTB(Rm)
				this.clockCount++;
				this.r[getu(0, 3)] = norm(this.r[getu(3, 3)] & 0xff);
			} else if (chk("1011001010")) { // Rd = UXTH(Rm)
				this.clockCount++;
				this.r[getu(0, 3)] = norm(this.r[getu(3, 3)] & 0xffff);
			} else if (chk("00010")) { // Rd = ASR(Rm, u5)
				this.clockCount++;
				var v = this.r[getu(3, 3)];
				var s = getu(6, 5); // 1 <= s <= 32
				if (s == 0) {
					this.r[getu(0, 3)] = this.setflg(norm(v >> 31));
					this.status.c = ((v >> 31) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(norm(v >> s));
					this.status.c = ((v >> (s - 1)) & 1) != 0;
				}
			} else if (chk("0100000100")) { // ASR Rd, Rs
				this.clockCount++;
				var v = this.r[getu(0, 3)];
				var s = this.r[getu(3, 3)];
				if (0 <= s && s < 32) {
					this.r[getu(0, 3)] = this.setflg(norm(v >> s));
					if (s != 0) this.status.c = ((v >> (s - 1)) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(norm(v >> 31));
					this.status.c = ((v >> 31) & 1) != 0;
				}
			} else if (chk("0100001110")) { // BIC Rd, Rm (Rd &= ~Rm)
				this.clockCount++;
				this.r[getu(0, 3)] = this.setflg(norm(this.r[getu(0, 3)] & ~this.r[getu(3, 3)]));
			} else if (chk("0100000111")) { // ROR Rd, Rs
				this.clockCount++;
				var v = this.r[getu(0, 3)];
				var s = this.r[getu(3, 3)];
				var s2 = s % 32;
				if (s2 == 0) {
					this.r[getu(0, 3)] = this.setflg(v);
					if (s != 0) this.status.c = ((v >> 31) & 1) != 0;
				} else {
					this.r[getu(0, 3)] = this.setflg(norm((v >>> s2) | (v << (32 - s2))));
					this.status.c = ((v >> (s2 - 1)) & 1) != 0;
				}
			} else if (chk("0100000101")) { // ADC Rd, Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.addsetflg(this.r[getu(0, 3)], this.r[getu(3, 3)], this.status.c);
			} else if (chk("0100000110")) { // SBC Rd, Rm
				this.clockCount++;
				this.r[getu(0, 3)] = this.subsetflg(this.r[getu(0, 3)], this.r[getu(3, 3)], !this.status.c);
			} else if (chk("11001")) { // LDM Rn, {regs}
				this.clockCount++;
				var regs = getu(0, 8);
				if (regs == 0) {
					throw "LDM with empty regs";
				}
				var dstidx = getu(8, 3);
				var addr = this.r[dstidx];
				for (var i = 0; i < 8; i++) {
					if ((regs >> i) & 1) {
						this.clockCount++;
						this.checkmem(addr, 4, false);
						this.r[i] = this.mem.get32(addr);
						addr = norm(addr + 4);
					}
				}
				if (!((regs >> dstidx) & 1)) {
					this.r[dstidx] = addr;
				}
			} else if (chk("11000")) { // STM Rn, {regs}
				this.clockCount++;
				var regs = getu(0, 8);
				if (regs == 0) {
					throw "STM with empty regs";
				}
				var dstidx = getu(8, 3);
				if (((regs >> dstidx) & 1) && (regs & ((1 << dstidx) - 1))) {
					throw "STM with invalid combination of Rn and regs";
				}
				var addr = this.r[dstidx];
				for (var i = 0; i < 8; i++) {
					if ((regs >> i) & 1) {
						this.clockCount++;
						this.checkmem(addr, 4, true);
						this.mem.set32(addr, this.r[i]);
						addr = norm(addr + 4);
					}
				}
				this.r[dstidx] = addr;
			} else if (chk("10111110")) { // BKPT u8
				throw "BKPT " + getu(0, 8) + " is executed";
			// SVC u8 is not here but before IF cond GOTO n8 because they have common prefix
			} else {
				if (get("unsupported_op").value === "halt") {
					throw "unsupported instruction";
				}
			}
		} catch(e) {
			var inst = code.toString(2);
			while (inst.length < 16) inst = "0" + inst;
			alert("" + e + "\n\ninstruction address: #" + iaddr.toString(16) +
				"\ninstruction: " + inst);
			return 0;
		}
//		dump(this.r);
		return 1;
	};
};

var CPU_RV32C = function() {
	this.r = [];
	this.pc = 0;
	this.instCount = 0;
	this.reset = function() {
		for (var i = 0; i < 32; i++)
			this.r[i] = 0;
		this.pc = 0;
		this.instCount = 0;
	};
	this.reset();
	
	this.mem = new MEM();
	this.step = function() {
		var iaddr = this.pc;
		if (iaddr === 0xDEADBEEE) { // 0xDEADBEEF & 0xfffffffe
			// instead of stopping execution at RET
			return 0;
		}
//		if (iaddr % 2 != 0) {
//			alert ("unaligned instructon read #" + iaddr.toString(16));
//			return 0;
//		}
		if (!this.mem.check(iaddr, 2) && get("uninitialized_memory").value === "halt") {
			alert("read instruction from uninitialized memory #" + iaddr.toString(16));
			return 0;
		}
		var code = this.mem.get16(iaddr);
		if ((code & 3) == 3) { // 32-bit instruction
			this.pc += 2;
			if (this.pc >= 0x100000000) this.pc -= 0x100000000;
			if (!this.mem.check(this.pc, 2) && get("uninitialized_memory").value === "halt") {
				alert("read instruction from uninitialized memory #" + this.pc.toString(16));
				return 0;
			}
			code = code | (this.mem.get16(this.pc) << 16);
		}
//		this.code = code;
		this.pc += 2;
		this.instCount++;
		if (this.pc >= 0x100000000) this.pc -= 0x100000000;
//		console.log(code.toString(2));
//		alert(code.toString(2));
		try {
			var getu = function(start, n) {
				return (code >> start) & ((1 << n) - 1);
			};
			var getn = function(start, n) {
				var res = (code >> start) & ((1 << n) - 1);
				if ((res >> (n - 1)) != 0)
					return res - (1 << n);
				return res;
			};
			var getus = function(poses) {
				var res = 0;
				for (var i = 0; i < poses.length; i++) {
					res |= getu(poses[i][0], poses[i][1]) << poses[i][2];
				}
				return res;
			};
			var getns = function(poses) {
				var res = 0;
				var maxPos = 1;
				for (var i = 0; i < poses.length; i++) {
					res |= getu(poses[i][0], poses[i][1]) << poses[i][2];
					var pos = poses[i][1] + poses[i][2];
					if (pos > maxPos) maxPos = pos;
				}
				if ((res >> (maxPos - 1)) != 0)
					return res - (1 << maxPos);
				return res;
			};
			var norm = function(n) {
				var v = 0x100000000;
				while (n >= v) n -= v;
				while (n < 0) n += v;
				return n;
			};
			var s = function(v) {
				if (v >= 0 && (v & 0x80000000)) return v - 0x100000000;
				return v;
			};
			var checkmem = (function(mem) {
				return function(addr, n, iswrite) {
//					if (addr % n != 0) {
//						throw "unaligned memory " + (iswrite ? "write" : "read") +
//							" #" + addr.toString(16);
//					}
					if (!iswrite && !mem.check(addr, n) &&
					get("uninitialized_memory").value === "halt") {
						throw "read from uninitialized memory #" + addr.toString(16);
					}
				};
			})(this.mem);
			var unsupported = function() {
				if (get("unsupported_op").value === "halt") {
					throw "unsupported instruction";
				}
			};
			var reserved = function() {
				throw "reserved";
			};
			switch(getu(0, 2)) {
				case 0x0:
				{
					var rd = getu(2, 3) + 8;
					var rs1 = getu(7, 3) + 8;
					var offset = getus([[10,3,3],[6,1,2],[5,1,6]]);
					var addr = norm(this.r[rs1] + offset);
					switch (getu(13, 3)) {
					case 0x0: // c.addi4spn
						{
							var u = getus([[11,2,4],[7,4,6],[6,1,2],[5,1,3]]);
							if (u == 0) reserved();
							this.r[rd] = norm(this.r[2] + u);
						}
						break;
					case 0x2: // c.lw
						checkmem(addr, 4, false);
						this.r[rd] = this.mem.get32(addr);
						break;
					case 0x6: // c.sw
						checkmem(addr, 4, true);
						this.mem.set32(addr, this.r[rd]);
						break;
					default:
						unsupported();
						break;
					}
				}
				break;
				case 0x1:
				{
					var imm = getns([[12,1,5],[2,5,0]]);
					var rd = getu(7, 5);
					switch (getu(13, 3)) {
						case 0x0: // c.nop / c.addi
							this.r[rd] = norm(this.r[rd] + imm);
							break;
						case 0x01: // c.jal
						{
							var offset = getns([[12,1,11],[11,1,4],[9,2,8],[8,1,10],[7,1,6],[6,1,7],[3,3,1],[2,1,5]]);
							this.r[1] = this.pc;
							this.pc = norm(this.pc - 2 + offset);
						}
						break;
						case 0x02: // c.li
							this.r[rd] = imm;
							break;
						case 0x03:
							if (rd == 2) { // c.addi16sp
								var offset = getns([[12,1,9],[6,1,4],[5,1,6],[3,2,7],[2,1,5]]);
								this.r[2] = norm(this.r[2] + offset);
							} else { // c.lui
								this.r[rd] = norm((imm << 12) & 0xffffffff);
							}
							break;
						case 0x04:
						{
							var rdd = getu(7, 3) + 8;
							switch (getu(10, 2)) {
								case 0x0: // c.srli
									if (imm & 0x20) reserved();
									this.r[rdd] = norm(this.r[rdd] >>> imm);
									break;
								case 0x1: // c.srai
									if (imm & 0x20) reserved();
									this.r[rdd] = norm(this.r[rdd] >> imm);
									break;
								case 0x2: // c.andi
									this.r[rdd] = norm(this.r[rdd] & imm);
									break;
								case 0x3:
									if (getu(12, 1) == 0) {
										var rs2d = getu(2, 3) + 8;
										switch (getu(5, 2)) {
											case 0x0: // c.sub
												this.r[rdd] = norm(this.r[rdd] - this.r[rs2d]);
												break;
											case 0x1: // c.xor
												this.r[rdd] = norm(this.r[rdd] ^ this.r[rs2d]);
												break;
											case 0x2: // c.or
												this.r[rdd] = norm(this.r[rdd] | this.r[rs2d]);
												break;
											case 0x3: // c.and
												this.r[rdd] = norm(this.r[rdd] & this.r[rs2d]);
												break;
											default:
												unsupported();
												break;
										}
									} else {
										reserved();
									}
									break;
								default:
									unsupported();
									break;
							}
						}
						break;
						case 0x05: // c.j
						{
							var offset = getns([[12,1,11],[11,1,4],[9,2,8],[8,1,10],[7,1,6],[6,1,7],[3,3,1],[2,1,5]]);
							this.pc = norm(this,pc - 2 + offset);
						}
						break;
						case 0x06: case 0x07:
						{
							var rsd = getu(7, 3) + 8;
							var offset = getns([[12,1,8],[10,2,3],[5,2,6],[3,2,1],[2,1,5]]);
							if (getu(13, 3) === 0x06) { // c.beqz
								if (this.r[rsd] === 0) {
									this.pc = norm(this.pc - 2 + offset);
								}
							} else { // c.bnez
								if (this.r[rsd] !== 0) {
									this.pc = norm(this.pc - 2 + offset);
								}
							}
						}
						break;
						default:
							unsupported();
							break;
					}
				}
				break;
				case 0x2:
					switch (getu(13, 3)) {
						case 0x0: // c.slli
						{
							if (getu(12, 1) != 0) reserved();
							var rd = getu(7, 5);
							var imm = getu(2, 5);
							this.r[rd] = norm(this.r[rd] << imm);
						}
						break;
						case 0x2: // c.lwsp
						{
							var offset = getus([[12,1,5],[4,3,2],[2,2,6]]);
							var rd = getu(7, 5);
							var addr = norm(this.r[2] + offset);
							checkmem(addr, 4, false);
							this.r[rd] = this.mem.get32(addr);
						}
						break;
						case 0x4:
						{
							var rd = getu(7, 5);
							var rs = getu(2, 5);
							if (getu(12, 1) === 0) {
								if (rs === 0) { // c.jr
									if (rd === 0) reserved();
									this.pc = norm(this.r[rd] & 0xfffffffe);
								} else { // c.mv
									this.r[rd] = this.r[rs];
								}
							} else {
								if (rs === 0) {
									if (rd === 0) { // c.ebreak
										throw "C.EBREAK is executed";
									} else { // c.jalr
										this.r[1] = this.pc;
										this.pc = norm(this.r[rd] & 0xfffffffe);
									}
								} else { // c.add
									this.r[rd] = norm(this.r[rd] + this.r[rs]);
								}
							}
						}
						break;
						case 0x6: // c.swsp
						{
							var offset = getus([[9,4,2],[7,2,6]]);
							var rs = getu(2, 5);
							var addr = norm(this.r[2] + offset);
							checkmem(addr, 4, true);
							this.mem.set32(addr, this.r[rs]);
						}
						break;
						default:
							unsupported();
							break;
					}
					break;
				case 0x3:
				{
					var rd = getu(7, 5);
					var funct3 = getu(12, 3);
					var rs1 = getu(15, 5);
					var rs2 = getu(20, 5);
					switch (getu(0, 7)) {
						case 0x37: // lui
							this.r[rd] = norm(code & 0xfffff000);
							break;
						case 0x17: // auipc
							this.r[rd] = norm(this.pc - 4 + (code & 0xfffff000));
							break;
						case 0x6F: //jal
						{
							var offset = getns([[31,1,20],[21,10,1],[20,1,11],[12,8,12]]);
							this.r[rd] = this.pc;
							this.pc = norm(this.pc - 4 + offset);
						}
						break;
						case 0x67:
							if (funct3 === 0) { // jalr
								this.r[rd] = this.pc;
								this.pc = norm((this.r[rs1] + getn(20, 12)) & 0xfffffffe);
							} else {
								unsupported();
							}
							break;
						case 0x63:
						{
							var offset = getns([[31,1,12],[25,6,5],[8,4,1],[7,1,11]]);
							var dest = norm(this.pc - 4 + offset);
							switch (funct3) {
								case 0:	// beq
									if (this.r[rs1] === this.r[rs2]) this.pc = dest;
									break;
								case 1:	// bne
									if (this.r[rs1] !== this.r[rs2]) this.pc = dest;
									break;
								case 4:	// blt
									if (s(this.r[rs1]) < s(this.r[rs2])) this.pc = dest;
									break;
								case 5:	// bge
									if (s(this.r[rs1]) >= s(this.r[rs2])) this.pc = dest;
									break;
								case 6:	// bltu
									if (this.r[rs1] < this.r[rs2]) this.pc = dest;
									break;
								case 7:	// bgeu
									if (this.r[rs1] >= this.r[rs2]) this.pc = dest;
									break;
								default:
									unsupported();
									break;
							}
						}
						break;
						case 0x03:
						{
							var offset = getn(20, 12);
							var addr = norm(this.r[rs1] + offset);
							switch (funct3) {
								case 0: // lb
								{
									checkmem(addr, 1, false);
									var res = this.mem.get(addr);
									if (res & 0x80) res = norm(res | 0xffffff00);
									this.r[rd] = res;
								}
								break;
								case 1: // lh
								{
									checkmem(addr, 2, false);
									var res = this.mem.get16(addr);
									if (res & 0x8000) res = norm(res | 0xffff0000);
									this.r[rd] = res;
								}
								break;
								case 2: // lw
									checkmem(addr, 4, false);
									this.r[rd] = this.mem.get32(addr);
									break;
								case 4: // lbu
									checkmem(addr, 1, false);
									this.r[rd] = this.mem.get(addr);
									break;
								case 5: // lhu
									checkmem(addr, 2, false);
									this.r[rd] = this.mem.get16(addr);
									break;
								default:
									unsupported();
									break;
							}
						}
						break;
						case 0x23:
						{
							var offset = getns([[25,7,5],[7,5,0]]);
							var addr = norm(this.r[rs1] + offset);
							switch (funct3) {
								case 0: // sb
									checkmem(addr, 1, true);
									this.mem.set(addr, this.r[rs2]);
									break;
								case 1: // sh
									checkmem(addr, 2, true);
									this.mem.set16(addr, this.r[rs2]);
									break;
								case 2: // sw
									checkmem(addr, 4, true);
									this.mem.set32(addr, this.r[rs2]);
									break;
								default:
									unsupported();
									break;
							}
						}
						break;
						case 0x13:
						{
							var imm = getn(20, 12);
							switch (funct3) {
								case 0: // addi
									this.r[rd] = norm(this.r[rs1] + imm);
									break;
								case 2: // slti
									this.r[rd] = s(this.r[rs1]) < imm ? 1 : 0;
									break;
								case 3: // sltiu
									this.r[rd] = this.r[rs1] < norm(imm) ? 1 : 0;
									break;
								case 4: // xori
									this.r[rd] = norm(this.r[rs1] ^ imm);
									break;
								case 6: // or
									this.r[rd] = norm(this.r[rs1] | imm);
									break;
								case 7: // andi
									this.r[rd] = norm(this.r[rs1] & imm);
									break;
								case 1:
									if (getu(25, 7) === 0) { // slli
										var shamt = getu(20, 5);
										this.r[rd] = norm((this.r[rs1] << shamt) & 0xffffffff);
									} else {
										unsupported();
									}
									break;
								case 5:
								{
									var shamt = getu(20, 5);
									switch (getu(25, 7)) {
										case 0x00: // srli
											this.r[rd] = norm(this.r[rs1] >>> shamt);
											break;
										case 0x20: // srai
											this.r[rd] = norm(this.r[rs1] >> shamt);
											break;
										default:
											unsupported();
											break;
									}
								}
								break;
								default:
									unsupported();
									break;
							}
						}
						break;
						case 0x33:
							switch (getu(25, 7)) {
								case 0x00:
									switch (funct3) {
										case 0: // add
											this.r[rd] = norm(this.r[rs1] + this.r[rs2]);
											break;
										case 1: // sll
											this.r[rd] = norm((this.r[rs1] << (this.r[rs2] & 0x1f)) & 0xffffffff);
											break;
										case 2: // slt
											this.r[rd] = s(this.r[rs1]) < s(this.r[rs2]) ? 1 : 0;
											break;
										case 3: // sltu
											this.r[rd] = this.r[rs1] < this.r[rs2] ? 1 : 0;
											break;
										case 4: // xor
											this.r[rd] = norm(this.r[rs1] ^ this.r[rs2]);
											break;
										case 5: // srl
											this.r[rd] = norm(this.r[rs1] >>> (this.r[rs2] & 0x1f));
											break;
										case 6: // or
											this.r[rd] = norm(this.r[rs1] | this.r[rs2]);
											break;
										case 7: // and
											this.r[rd] = norm(this.r[rs1] & this.r[rs2]);
											break;
										default:
											unsupported();
											break;
									}
									break;
								case 0x20:
									switch (funct3) {
										case 0: // sub
											this.r[rd] = norm(this.r[rs1] - this.r[rs2]);
											break;
										case 5: // sra
											this.r[rd] = norm(this.r[rs1] >> (this.r[rs2] & 0x1f));
											break;
										default:
											unsupported();
											break;
									}
									break;
								case 0x01:
									switch (funct3) {
										case 0: // mul
										case 1: // mulh
										case 2: // mulhsu
										case 3: // mulhu
										{
											var v1 = this.r[rs1], v2 = this.r[rs2];
											var minus = false;
											if ((v1 & 0x80000000) && (funct3 < 3)) {
												v1 = norm(-v1);
												minus = !minus;
											}
											if ((v2 & 0x80000000) && (funct3 < 2)) {
												v2 = norm(-v2);
												minus = !minus;
											}
											var v1l = v1 & 0xffff, v1h = (v1 >>> 16) & 0xffff;
											var v2l = v2 & 0xffff, v2h = (v2 >>> 16) & 0xffff;
											var ll = v1l * v2l;
											var lh = v1l * v1h, hl = v1h * v2l;
											var hh = v1h * v2h;
											var rl_l = ll & 0xffff;
											var rl_h = ((ll >>> 16) & 0xffff) + (lh & 0xffff) + (hl & 0xffff);
											var rh = norm(hh + ((rl_h >>> 16) & 0xffff));
											var rl = norm(((rl_h & 0xffff) << 16) | rl_l);
											if (minus) {
												rh = norm(~rh);
												rl = norm(~rl);
												if (rl === 0xffffffff) {
													rh = norm(rh + 1);
													rl = 0;
												} else {
													rl = norm(rl + 1);
												}
											}
											if (funct3 === 0) {
												this.r[rd] = rl;
											} else {
												this.r[rd] = rh;
											}
										}
										break;
										case 4: // div
											if (this.r[rs2] === 0) {
												this.r[rd] = 0xffffffff;
											} else if (this.r[rs1] === 0x80000000 && this.r[rs2] === 0xffffffff) {
												this.r[rd] = 0x80000000;
											} else {
												this.r[rd] = norm(~~(s(this.r[rs1]) / s(this.r[rs2])));
											}
											break;
										case 5: // divu
											if (this.r[rs2] === 0) {
												this.r[rd] = 0xffffffff;
											} else {
												this.r[rd] = norm(~~(this.r[rs1] / this.r[rs2]));
											}
											break;
										case 6: // rem
											if (this.r[rs2] === 0) {
												this.r[rd] = this.r[rs1];
											} else if (this.r[rs1] === 0x80000000 && this.r[rs2] === 0xffffffff) {
												this.r[rd] = 0;
											} else {
												var dividend = s(this.r[rs1]);
												var divisor = s(this.r[rs2]);
												var quotient = s(~~(dividend / divisor));
												this.r[rd] = norm(dividend - divisor * quotient);
											}
											break;
										case 7: // remu
											if (this.r[rs2] === 0) {
												this.r[rd] = this.r[rs1];
											} else {
												this.r[rd] = norm(this.r[rs1] % this.r[rs2]);
											}
											break;
										default:
											unsupported();
											break;
									}
									break;
								default:
									unsupported();
									break;
							}
							break;
						case 0x0F: // fence
							// ignore (reserved conifiguration -> treat as normal fence)
							break;
						case 0x73:
							if (rd === 0 && funct3 === 0 && rs1 === 0) {
								switch (getu(20, 12)) {
									case 0: // ecall
										throw "ECALL executed";
									case 1: // ebreak
										throw "EBREAK executed";
									default:
										unsupported();
										break;
								}
							} else {
								unsupported();
							}
							break;
						default:
							unsupported();
							break;
					}
				}
				break;
				default:
					unsupported();
					break;
			}
		} catch(e) {
			var inst = code.toString(2);
			while (inst.length < 16) inst = "0" + inst;
			alert("" + e + "\n\ninstruction address: #" + iaddr.toString(16) +
				"\ninstruction: " + inst);
			return 0;
		} finally {
			this.r[0] = 0;
		}
//		dump(this.r);
		return 1;
	};
};

window.onload = function() {
	var MODE_M0 = 0;
	var MODE_RV32C = 1;
	
	var cpu_m0 = new CPU_M0();
	var cpu_rv32c = new CPU_RV32C();
	var cpu = cpu_m0;
	var cpu_mode = MODE_M0;
	
	var parseRegValue = function(rawRes) {
		var res = null;
		if (rawRes !== null) {
			rawRes = rawRes.replace(/\s+/g, "");
			if (rawRes.substr(0, 1) == '`') {
				res = parseInt(rawRes.substr(1), 2);
			} else if (rawRes.substr(0, 1) == '#') {
				res = parseInt(rawRes.substr(1), 16);
			} else {
				res = parseInt(rawRes);
			}
			if (!isNaN(res)) {
				res = res & 0xffffffff;
				if (res < 0) res += 0x100000000;
			}
		}
		return res;
	};
	
	var regshow_m0 = create("div");
	for (var i = 0; i < 16; i++) {
		var r = create("div");
		r.textContent = "R" + i + ": ";
		r.ondblclick = (function(idx) {
			return function() {
				var res = parseRegValue(prompt("R" + idx + "の値を入力", cpu.r[idx]));
				if (res !== null && !isNaN(res)) {
					cpu.r[idx] = res;
					showRegs();
				}
			};
		})(i);
		regshow_m0.appendChild(r);
	}
	var flgnames = ["Negative", "Zero", "Carry", "Overflow"];
	for (var i = 0; i < 4; i++) {
		var r = create("div");
		r.textContent = flgnames[i] + "-flg: ";
		regshow_m0.appendChild(r);
	}
	{
		var r = create("div");
		r.style["margin-top"] = "1em";
		r.textContent = "Clock: ";
		regshow_m0.appendChild(r);
	}
	get("regs").appendChild(regshow_m0);
	
	var regshow_rv32c = create("div");
	for (var i = 0; i < 32; i++) {
		var r = create("div");
		r.textContent = "R" + i + ": ";
		if (i !== 0) {
			r.ondblclick = (function(idx) {
				return function() {
					var res = parseRegValue(prompt("R" + idx + "の値を入力", cpu.r[idx]));
					if (res !== null && !isNaN(res)) {
						cpu.r[idx] = res;
						showRegs();
					}
				};
			})(i);
		}
		regshow_rv32c.appendChild(r);
	}
	{
		var r = create("div");
		r.textContent = "PC: ";
		r.ondblclick =  function() {
			var res = parseRegValue(prompt("PCの値を入力", cpu.pc));
			if (res !== null && !isNaN(res)) {
				cpu.pc = res;
				showRegs();
			}
		};
		regshow_rv32c.appendChild(r);
		
		var r2 = create("div");
		r2.style["margin-top"] = "1em";
		r2.textContent = "Insts: ";
		regshow_rv32c.appendChild(r2);
	}
	regshow_rv32c.style.display = "none";
	get("regs").appendChild(regshow_rv32c);
	
	var showRegs = function() {
		if (cpu_mode === MODE_M0) {
			var rs = regshow_m0.childNodes;
			for (var i = 0; i < 16; i++) {
				var negative = "";
				if (cpu.r[i] & 0x80000000) {
					negative = " (" + (cpu.r[i] - 0x100000000) + ")";
				}
				rs[i].textContent = "R" + i + ": " + cpu.r[i] + negative + " #" + cpu.r[i].toString(16);
			}
			rs[16].textContent = flgnames[0] + "-flg: " + cpu.status.n;
			rs[17].textContent = flgnames[1] + "-flg: " + cpu.status.z;
			rs[18].textContent = flgnames[2] + "-flg: " + cpu.status.c;
			rs[19].textContent = flgnames[3] + "-flg: " + cpu.status.v;
			rs[20].textContent = "Clock: " + cpu.clockCount;
		} else if (cpu_mode == MODE_RV32C) {
			var rs = regshow_rv32c.childNodes;
			for (var i = 0; i < 32; i++) {
				var negative = "";
				if (cpu.r[i] & 0x80000000) {
					negative = " (" + (cpu.r[i] - 0x100000000) + ")";
				}
				rs[i].textContent = "R" + i + ": " + cpu.r[i] + negative + " #" + cpu.r[i].toString(16);
			}
			rs[32].textContent = "PC: " + cpu.pc + " #" + cpu.pc.toString(16);
			rs[33].textContent = "Insts: " + cpu.instCount;
		}
	};
	
	var memDumpStartAddress = 0;
	var t, tr;
	t = create("table");
	tr = create("tr");
	tr.appendChild(create("th"));
	for (var i = 0; i < 16; i++) {
		var th = create("th");
		th.textContent = i.toString(16);
		if (i % 4 == 0) th.className = "mark";
		tr.appendChild(th);
	}
	t.appendChild(tr);
	var addressCellList = [];
	var byteCellList = [];
	var wordCellList = [];
	var longCellList = [];
	for (var i = 0; i < 0x1000; i += 16) {
		tr = create("tr");
		var td = create("td");
		td.textContent = "#" + i.toString(16);
		addressCellList.push(td);
		tr.appendChild(td);
		for (var j = 0; j < 16; j++) {
			td = create("td");
			td.textContent = "#00";
			if (j % 4 == 0) td.className = "mark";
			byteCellList.push(td);
			tr.appendChild(td);
			if (j % 2 == 0) {
				td = create("td");
				td.textContent = "#0000";
				td.colSpan = 2;
				td.style.display = "none";
				wordCellList.push(td);
				tr.appendChild(td);
			}
			if (j % 4 == 0) {
				td = create("td");
				td.textContent = "#00000000";
				td.colSpan = 4;
				td.style.display = "none";
				longCellList.push(td);
				tr.appendChild(td);
			}
		}
		t.appendChild(tr);
	}
	var displayingCellList = byteCellList;
	get("mem").appendChild(t);
	var memDumpFunc = function() {
		var kind = get("mem_format").value;
		if (kind == "signed") {
			return function(n, w) {
				if (w == 4) {
					return (n >= 0x80000000 ? n - 0x100000000 : n).toString(10);
				} else {
					var threshold = 1 << (w * 8 - 1);
					return (n >= threshold ? n - (1 << (w * 8)) : n).toString(10);
				}
			}
		} else if (kind == "unsigned") {
			return function(n, w) {
				return n.toString(10);
			}
		} else {
			return function(n, w) {
				var ret = n.toString(16);
				while (ret.length < w * 2) ret = "0" + ret;
				return "#" + ret;
			}
		}
	};
	var memNotifyFunc = function(addr) {
		var daddr = addr - memDumpStartAddress;
		if (0 <= daddr && daddr < 0x1000) {
			var f = memDumpFunc();
			byteCellList[daddr].textContent =
				cpu.mem.check(daddr + memDumpStartAddress, 1) ?
					f(cpu.mem.get(daddr + memDumpStartAddress), 1) : "??";
			var addrw = daddr >> 1;
			wordCellList[addrw].textContent =
				cpu.mem.check(addrw * 2 + memDumpStartAddress, 2) ?
					f(cpu.mem.get16(addrw * 2 + memDumpStartAddress), 2) : "????";
			var addrl = daddr >> 2;
			longCellList[addrl].textContent =
				cpu.mem.check(addrl * 4 + memDumpStartAddress, 4) ?
					f(cpu.mem.get32(addrl * 4 + memDumpStartAddress), 4) : "????????";
		}
	};
	cpu_m0.mem.notify = memNotifyFunc;
	cpu_rv32c.mem.notify = memNotifyFunc;
	var memDumpUpdateAll = function() {
		var f = memDumpFunc();
		for (var i = 0; i < 0x1000; i++) {
			var addr = memDumpStartAddress + i;
			byteCellList[i].textContent =
				cpu.mem.check(addr, 1) ? f(cpu.mem.get(addr), 1) : "??";
		}
		for (var i = 0; i < 0x1000; i += 2) {
			var addr = memDumpStartAddress + i;
			wordCellList[i >> 1].textContent =
				cpu.mem.check(addr, 2) ? f(cpu.mem.get16(addr), 2) : "????";
		}
		for (var i = 0; i < 0x1000; i += 4) {
			var addr = memDumpStartAddress + i;
			longCellList[i >> 2].textContent =
				cpu.mem.check(addr, 4) ? f(cpu.mem.get32(addr), 4) : "????????";
		}
		for (var i = 0; i < addressCellList.length; i++) {
			addressCellList[i].textContent = "#" + (memDumpStartAddress + i * 16).toString(16);
		}
	};
	var memDumpSwitchLength = function() {
		for (var i = 0; i < displayingCellList.length; i++) displayingCellList[i].style.display = "none";
		var arr;
		var len = get("mem_length").value;
		if (len === "byte") arr = byteCellList;
		else if (len === "word") arr = wordCellList;
		else if (len === "long") arr = longCellList;
		else arr = [];
		for (var i = 0; i < arr.length; i++) arr[i].style.display = "";
		displayingCellList = arr;
	};
	var memDumpSwitchSaddr = function() {
		var newval = parseInt(get("mem_saddr").value);
		if (!isNaN(newval) && 0 <= newval && newval <= 0x100000000 - 0x1000) {
			memDumpStartAddress = newval - (newval % 16);
			memDumpUpdateAll();
		}
	};
	get("mem_format").onchange = memDumpUpdateAll;
	get("mem_length").onchange = memDumpSwitchLength;
	get("mem_apply_saddr").onclick = memDumpSwitchSaddr;
	memDumpSwitchLength();
	memDumpSwitchSaddr();
	
	var prevRealMode = 0;
	var reset = function() {
		var newMode = parseInt(get("cpu_select").value);
		if (newMode === MODE_M0) {
			cpu = cpu_m0;
			regshow_m0.style.display = "";
			regshow_rv32c.style.display = "none";
			cpu_mode = MODE_M0;
		} else if (newMode === MODE_RV32C) {
			cpu = cpu_rv32c;
			regshow_m0.style.display = "none";
			regshow_rv32c.style.display = "";
			cpu_mode = MODE_RV32C;
		}
		var realMode = parseInt(get("real_mode").value);
		cpu.reset();
		if (cpu_mode === MODE_M0) {
			cpu.r[1] = 0x100;
			cpu.r[13] = 0x1000; // SP
			cpu.r[14] = 0xDEADBEEF; // LR
			cpu.r[15] = 0; // PC
		} else if (cpu_mode === MODE_RV32C) {
			cpu.r[11] = 0x100;
			cpu.r[2] = 0x1000; // SP
			cpu.r[1] = 0xDEADBEEE; // RA
			cpu.pc = 0;
		}
		cpu.mem.ram = [];
		if (realMode > 0 && prevRealMode === 0 && memDumpStartAddress === 0) {
			memDumpStartAddress = 0x10000000;
		} else if (realMode === 0 && prevRealMode > 0 && memDumpStartAddress === 0x10000000) {
			memDumpStartAddress = 0;
		}
		prevRealMode = realMode;
		memDumpUpdateAll();
		if (realMode > 0) {
			var font = realMode >= 12 ? ijfont_1_2 : ijfont_1_1;
			var crom_addr = 0x1000;
			var cram_addr = 0x10000000;
			var div_addr = 0x2000;
			var div_data = [
				0x0A,0x46,0x01,0x46,0x00,0x20,0x01,0x23,
				0x91,0x42,0x0E,0xD3,0x12,0x42,0x0C,0xD0,
				0x04,0xD4,0x5B,0x00,0x52,0x00,0x01,0xD4,
				0x8A,0x42,0xFA,0xD3,0x91,0x42,0x01,0xD3,
				0x89,0x1A,0xC0,0x18,0x52,0x08,0x5B,0x08,
				0xF8,0xD1,0x70,0x47
			];
			for (var i = 0; i < 0xe0 * 8; i++) {
				cpu.mem.set(crom_addr + i, font[i]);
			}
			for (var i = 0; i < 0x20 * 8; i++) {
				cpu.mem.set(cram_addr + i, font[i + 0xe0 * 8]);
			}
			if (realMode >= 11) {
				if (cpu_mode === MODE_M0) {
					cpu.r[1] = cram_addr - 0x700;
					cpu.r[2] = crom_addr;
				} else if (cpu_mode === MODE_RV32C) {
					cpu.r[11] = cram_addr - 0x700;
					cpu.r[12] = crom_addr;
				}
			}
			if (realMode >= 12) {
				for (var i = 0; i < div_data.length; i++) {
					cpu.mem.set(div_addr + i, div_data[i]);
				}
				if (cpu_mode === MODE_M0) {
					cpu.r[3] = div_addr | 1;
				} else if (cpu_mode === MODE_RV32C) {
					cpu.r[13] = div_addr;
				}
			}
			if (cpu_mode === MODE_M0) {
				cpu.r[13] = 0x10001000;
				cpu.r[15] = 0x10000000;
			} else if (cpu_mode === MODE_RV32C) {
				cpu.r[2] = 0x10001000;
				cpu.pc = 0x10000000;
			}
		}
		autoflg = false;
		get("auto").textContent = "START";
		
		var n = 0;
		var memWrites = readMachineCode(get("prog").value);
		var binExists = false, pokeExists = false, arrayExists = false;
		for (var i = 0; i < memWrites.length; i++) {
			var kind = memWrites[i][2];
			if (kind === "bin") binExists = true;
			else if (kind === "poke") pokeExists = true;
			else if (kind === "array") arrayExists = true;
		}

		var offset = 0;
		if (realMode === 0) {
			if (binExists) offset = 0;
			else if (pokeExists) offset = 0x700;
			else if (arrayExists) offset = 0x800;
		} else {
			if (binExists) offset = 0;
			else if (pokeExists || arrayExists) offset = 0x700;
			offset -= 0x10000000;
		}
		for (var i = 0; i < memWrites.length; i++) {
			var addr = memWrites[i][0] - offset;
			cpu.mem.set(addr, memWrites[i][1]);
		}
		showRegs();
	};
	var autoflg = false;
	var auto = function() {
		if (autoflg) {
			autoflg = false;
			get("auto").textContent = "START";
			return;
		} else {
			autoflg = true;
			get("auto").textContent = "STOP";
		}
		var autostep = function() {
			if (!autoflg)
				return;
			if (cpu.step()) {
				setTimeout(autostep, get("autostep_interval").value);
			} else {
				autoflg = false;
				get("auto").textContent = "START";
			}
			showRegs();
		};
		autostep();
	};
	
	get("reset").onclick = reset;
	get("step").onclick = function() {
		autoflg = false;
		get("auto").textContent = "START";
		cpu.step();
		showRegs();
	};
	get("auto").onclick = auto;
	reset();
};

</script>
<style>
#credit {
	margin-top: 20px;
}
#prog {
	height: 520px;
	width: 14em;
	display: inline-block;
	font-size: 14px;
}
#regs {
	height: 400px;
	width: 23em;
	display: inline-block;
	font-size: 14px;
	vertical-align: top;
}
#mem {
	height: 400px;
	display: inline-block;
	font-size: 14px;
	vertical-align: top;
}
#mem table {
	display: block;
	overflow-y: scroll;
	height: 27em;
}
#mem td,th {
	border: 1px solid black;
	font-size: 14px;
	width: 2.5em;
}
#mem th:first-child {
	width: auto;
}
#mem td {
	text-align: right;
}
#mem .mark {
	background-color: #eee;
}

#config {
	margin-top: 1em;
	margin-bottom: 1em;
	font-size: 14px;
}
#main {
	padding: .5em;
}
a {
	color: #333 !important;
}
</style>
</head>
<body>

<h1>cpuemu - Alpha1</h1>
<div id=main>
使えるマシン語一覧: <a href=http://fukuno.jig.jp/1188>IchigoJamではじめるARMマシン語その3</a><br>
<br><textarea id=prog>0010001100001001
0000001000011011
0101010001011011
0011001100000001
0000101000011010
0010101000001010
1101000111111010
0100011101110000
</textarea>
<div id=regs></div>
<div id=mem>
format:<select id="mem_format">
<option value="hex" selected="selected">hex</option>
<option value="unsigned">unsigned dec</option>
<option value="signed">signed dec</option>
</select>
&nbsp;length:<select id="mem_length">
<option value="byte" selected="selected">byte</option>
<option value="word">word</option>
<option value="long">long</option>
</select>
&nbsp;start addr:<input id="mem_saddr" type="text" value="0x0" size="12">
<input id="mem_apply_saddr" type="button" value="GO">
<br>
</div>
<br>
<button id=auto>START</button>
<button id=step>STEP</button>
<button id=reset>RESET</button>
</div>
<div id="config">
CPUの種類は<select id="cpu_select">
<option value="0" selected="selected">従来型</option>
<option value="1">新型</option>
</select><br>
未サポートの命令<select id="unsupported_op">
<option value="ignore">を無視</option>
<option value="halt" selected="selected">で停止</option>
</select><br>
未初期化のメモリを読んだら<select id="uninitialized_memory">
<option value="zero">0とみなす</option>
<option value="halt" selected="selected">停止する</option>
</select><br>
自動実行の速さは<select id="autostep_interval">
<option value="10">高速</option>
<option value="100" selected="selected">通常</option>
</select><br>
IchigoJam再現モード<select id="real_mode">
<option value="0" selected="selected">オフ</option>
<option value="10">1.0風</option>
<option value="11">1.1風</option>
<option value="12">1.2風</option>
</select> ※非公認
</div>
<div id='credit'>
cpuemu a1 (for <a href=http://ichigojam.net/>IchigoJam</a>)<br>
<a href="https://ichigojam.github.io/asm15/cpuemu.html">Original</a> APP: <a href='http://fukuno.jig.jp/1328'>CC BY fukuno.jig.jp</a><br>
Modified By みけCAT<br>
Modification: <a href="https://creativecommons.org/licenses/by/4.0/deed.ja">CC BY 4.0</a> by みけCAT<br>
IchigoJam FONT(Original): CC BY IchigoJam(<a href="http://ichigojam.net/">http://ichigojam.net/</a>)
</div>

</body>
<html>
